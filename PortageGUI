import sys
import os
import subprocess
import re
import math
import traceback # For better error reporting
from collections import defaultdict # For grouping queue actions
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QListWidget, QPushButton, QLineEdit, QLabel,
    QStatusBar, QProgressBar, QMessageBox, QTextEdit, QSplitter,
    QListWidgetItem, QTreeWidget, QTreeWidgetItem, QHeaderView
)
from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QObject, QTimer, QRunnable, QThreadPool
)
from PyQt6.QtGui import QPalette, QColor, QIcon, QTextCursor # Import QIcon, QTextCursor
try:
    from ansi2html import Ansi2HTMLConverter
except ImportError:
    print("Warning: 'ansi2html' library not found. Output coloring disabled. Install with: pip install ansi2html")
    Ansi2HTMLConverter = None # type: ignore
COMMAND_TIMEOUT = 300
REFRESH_INTERVAL = 300000
APP_ICON_PATH = "/usr/share/icons/hicolor/48x48/apps/system-software-install.png" # Example path
ACTION_INSTALL = "install"
ACTION_UNINSTALL = "uninstall"
ACTION_UPDATE = "update"
class WorkerSignals(QObject):
    finished = pyqtSignal()
    error = pyqtSignal(str, str)
    result = pyqtSignal(object)
    progress = pyqtSignal(str)
    progress_val = pyqtSignal(int, int)
    status_update = pyqtSignal(str)
class CommandWorker(QRunnable): # Use QRunnable for QThreadPool compatibility
    def __init__(self, command_list, use_pkexec=False, collect_output=False):
        super().__init__()
        self.command_list = command_list
        self.signals = WorkerSignals()
        self.use_pkexec = use_pkexec
        self.collect_output = collect_output
        self.process = None
        self.is_cancelled = False
    def run(self):
        command_str = ' '.join(self.command_list)
        full_command = self.command_list
        collected_stdout = []
        try:
            if self.use_pkexec:
                if subprocess.run(['which', 'pkexec'], capture_output=True, text=True).returncode != 0:
                    self.signals.error.emit(command_str, "Error: 'pkexec' command not found. Is PolicyKit installed?")
                    self.signals.finished.emit()
                    return
                full_command = ['pkexec', '--disable-internal-agent'] + self.command_list
                command_str = 'pkexec ' + command_str # Update for error reporting
            self.signals.status_update.emit(f"Running: {' '.join(full_command)}...") # More informative status
            self.process = subprocess.Popen(
                full_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1, # Line buffered
                errors='replace', # Handle potential decoding errors
                preexec_fn=os.setsid # Create process group for easier killing
            )
            if self.process.stdout:
                for line in iter(self.process.stdout.readline, ''):
                    if self.is_cancelled:
                        break
                    line_strip = line.strip()
                    self.signals.progress.emit(line_strip) # Emit raw line for console
                    if self.collect_output:
                        collected_stdout.append(line_strip) # Store if needed
                self.process.stdout.close()
            if self.is_cancelled:
                self.signals.finished.emit()
                return # Don't proceed further if cancelled
            stderr_output = ""
            if self.process.stderr:
                stderr_output = self.process.stderr.read()
                self.process.stderr.close()
            return_code = self.process.poll()
            if return_code is None:
                try:
                    self.process.wait(timeout=COMMAND_TIMEOUT)
                    return_code = self.process.returncode
                except subprocess.TimeoutExpired:
                    self.process.kill() # Ensure it's stopped before trying killpg
                    try:
                        pgid = os.getpgid(self.process.pid)
                        os.killpg(pgid, 9) # SIGKILL group
                    except ProcessLookupError:
                        pass # Process might have died already
                    except Exception as ke:
                        print(f"Warning: Error during group kill after timeout: {ke}")
                    self.signals.error.emit(command_str, f"Command timed out after {COMMAND_TIMEOUT} seconds.")
                    self.signals.finished.emit()
                    return
            if return_code != 0:
                error_message = f"Command failed with exit code {return_code}.\n"
                error_message += f"Command: {' '.join(full_command)}\n"
                if stderr_output:
                    error_message += f"Stderr:\n{stderr_output.strip()}"
                else:
                    stdout_for_error = "\n".join(collected_stdout[-10:]) # Last 10 lines might help
                    if stdout_for_error:
                        error_message += f"\nLast Output Lines:\n{stdout_for_error}"
                    else:
                        error_message += "Check console output for details (no specific stderr)."
                if "emerge --sync" in command_str:
                    if "are you root?" in stderr_output.lower() or "permission denied" in stderr_output.lower():
                        error_message += "\n\nHint: Sync requires root privileges. Check pkexec configuration or run command manually."
                self.signals.error.emit(command_str, error_message)
            else:
                if self.collect_output:
                    self.signals.result.emit("\n".join(collected_stdout))
                else:
                    self.signals.result.emit("Command finished successfully.") # Send generic success
        except FileNotFoundError:
            self.signals.error.emit(command_str, f"Error: Command '{self.command_list[0]}' not found. Is it installed and in PATH?")
        except subprocess.TimeoutExpired: # Should be caught above, but as fallback
            if self.process: self.process.kill()
            self.signals.error.emit(command_str, f"Command timed out unexpectedly.\nCommand: {' '.join(full_command)}")
        except Exception as e:
            self.signals.error.emit(command_str, f"An unexpected error occurred in worker: {e}\nCommand: {' '.join(full_command)}\n{traceback.format_exc()}")
        finally:
            self.signals.finished.emit() # Always emit finished
    def stop(self):
        self.is_cancelled = True
        if self.process and self.process.poll() is None: # Check if process is running
            self.signals.status_update.emit("Attempting process termination...")
            try:
                pgid = os.getpgid(self.process.pid)
                os.killpg(pgid, 15) # Send SIGTERM to process group
                try:
                    self.process.wait(timeout=2) # Wait a bit for graceful exit
                    self.signals.status_update.emit("Process terminated.")
                    self.signals.error.emit(' '.join(self.command_list), "Operation Cancelled") # Emit error signal on cancel
                except subprocess.TimeoutExpired:
                    self.signals.status_update.emit("Forcing process termination (SIGKILL)...")
                    os.killpg(pgid, 9) # Send SIGKILL to process group if TERM failed
                    self.signals.error.emit(' '.join(self.command_list), "Operation Forcefully Cancelled") # Emit error signal on cancel
            except ProcessLookupError:
                self.signals.status_update.emit("Process already finished.")
            except Exception as e:
                self.signals.status_update.emit(f"Could not stop process group ({e}), trying direct kill...")
                try:
                    self.process.kill() # SIGKILL directly to the process
                    self.signals.error.emit(' '.join(self.command_list), "Operation Forcefully Cancelled")
                except Exception as ke:
                    self.signals.status_update.emit(f"Could not stop process: {ke}")
                    self.signals.error.emit(' '.join(self.command_list), f"Cancellation Failed: {ke}")
        else:
             pass # Or emit a status update if desired
class GentooPackageManagerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gentoo GUI Package Manager")
        self.setGeometry(100, 100, 1000, 700)
        if os.path.exists(APP_ICON_PATH):
            self.setWindowIcon(QIcon(APP_ICON_PATH))
        else:
            print(f"Warning: Application icon not found at {APP_ICON_PATH}")
        self.threadpool = QThreadPool()
        self.active_workers = 0 # Count active workers
        self.current_action_worker = None # Reference to the worker handling queue apply/sync/etc.
        self.installed_packages = [] # List of full "cat/pkg-ver" strings
        self.installed_packages_map = {} # Map "cat/pkg" -> "cat/pkg-ver" for easy lookup
        self.available_packages_by_cat = {} # category -> list of "cat/pkg" atoms
        self.update_list = [] # Stores actionable "cat/pkg" atoms for updates
        self.pending_actions = {} # Stores packages queued for actions: "cat/pkg": ACTION_TYPE
        self._commands_to_run = [] # Internal list for sequential commands in apply_queue
        self._original_atoms_for_cleanup = [] # Internal list for queue cleanup
        self.ansi_converter = Ansi2HTMLConverter(inline=True, dark_bg=True) if Ansi2HTMLConverter else None
        self.setup_ui()
        self.apply_dark_mode()
        self.refresh_all() # Use refresh_all for initial load
        self.disk_space_timer = QTimer(self)
        self.disk_space_timer.timeout.connect(self.refresh_disk_space)
        self.disk_space_timer.start(REFRESH_INTERVAL)
    def setup_ui(self):
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(0) # Remove spacing between widgets in the main layout
        self.tabs = QTabWidget()
        self.layout.addWidget(self.tabs)
        self.browse_tab = QWidget()
        self.installed_tab = QWidget()
        self.queue_tab = QWidget() # Renamed from search_tab
        self.update_tab = QWidget()
        self.output_tab = QWidget() # Tab to show command output
        self.tabs.addTab(self.browse_tab, "Browse Packages")
        self.tabs.addTab(self.installed_tab, "Installed Packages")
        self.tabs.addTab(self.queue_tab, "Queue") # Renamed
        self.tabs.addTab(self.update_tab, "Updates")
        self.tabs.addTab(self.output_tab, "Output Console")
        self._setup_browse_tab()
        self._setup_installed_tab()
        self._setup_queue_tab() # Renamed
        self._setup_update_tab()
        self._setup_output_tab()
        self.bottom_bar_widget = QWidget() # Use a widget for better styling control
        self.bottom_bar_layout = QHBoxLayout(self.bottom_bar_widget)
        self.bottom_bar_layout.setContentsMargins(5, 5, 5, 5) # Add some padding inside the bar
        self.layout.addWidget(self.bottom_bar_widget) # Add the bar widget to main layout
        self.refresh_button = QPushButton("Refresh Lists")
        self.refresh_button.setToolTip("Reload Installed, Updates, and Available Packages lists.")
        self.refresh_button.clicked.connect(self.refresh_all)
        self.bottom_bar_layout.addWidget(self.refresh_button)
        self.sync_button = QPushButton("Sync Repositories")
        self.sync_button.setToolTip("Run 'emerge --sync' (requires root privileges via pkexec).")
        self.sync_button.clicked.connect(self.run_sync)
        self.bottom_bar_layout.addWidget(self.sync_button)
        self.cancel_button = QPushButton("Cancel Action")
        self.cancel_button.setToolTip("Attempt to cancel the current Apply Queue or Sync operation.")
        self.cancel_button.clicked.connect(self.cancel_action_worker)
        self.cancel_button.setEnabled(False) # Disabled initially
        self.bottom_bar_layout.addWidget(self.cancel_button)
        self.bottom_bar_layout.addStretch(1) # Push status stuff to the right
        self.disk_space_label = QLabel("Disk: ?/? GB")
        self.bottom_bar_layout.addWidget(self.disk_space_label) # Add disk space to HBox
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar) # Use the dedicated status bar area
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setRange(0, 0) # Indeterminate initially
        self.progress_bar.setVisible(False) # Hide initially
        self.progress_bar.setMaximumHeight(18) # Make progress bar less tall
        self.status_bar.addPermanentWidget(self.progress_bar, 1) # Takes stretch space
    def _setup_browse_tab(self):
        tab_layout = QVBoxLayout(self.browse_tab) # Main layout for the tab
        filter_layout = QHBoxLayout() # Layout for filter and potentially other controls
        filter_layout.addWidget(QLabel("Filter:"))
        self.browse_filter_input = QLineEdit()
        self.browse_filter_input.setPlaceholderText("Filter packages (leave category tree empty to search all)...")
        self.browse_filter_input.textChanged.connect(self._filter_browse_list)
        filter_layout.addWidget(self.browse_filter_input)
        tab_layout.addLayout(filter_layout) # Add filter layout to tab layout
        splitter = QSplitter(Qt.Orientation.Horizontal)
        tab_layout.addWidget(splitter, 1) # Add splitter, make it take available space
        cat_widget = QWidget()
        cat_layout = QVBoxLayout(cat_widget)
        cat_layout.setContentsMargins(0,0,0,0)
        self.category_tree = QTreeWidget()
        self.category_tree.setHeaderLabel("Categories")
        self.category_tree.itemSelectionChanged.connect(self.category_selected)
        cat_layout.addWidget(self.category_tree)
        splitter.addWidget(cat_widget)
        right_pane_widget = QWidget()
        right_layout = QVBoxLayout(right_pane_widget)
        right_layout.setContentsMargins(0,0,0,0)
        self.browse_package_list = QListWidget()
        self.browse_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        right_layout.addWidget(self.browse_package_list, 1) # Make list take available space
        browse_button_layout = QHBoxLayout()
        self.browse_add_queue_button = QPushButton("Add Selected to Install Queue")
        self.browse_add_queue_button.clicked.connect(self.add_browse_to_queue)
        browse_button_layout.addStretch(1) # Push button to the right
        browse_button_layout.addWidget(self.browse_add_queue_button)
        right_layout.addLayout(browse_button_layout)
        splitter.addWidget(right_pane_widget)
        splitter.setSizes([250, 750]) # Adjust initial sizes (smaller category list)
    def _setup_installed_tab(self):
        layout = QVBoxLayout(self.installed_tab)
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Filter:"))
        self.installed_filter_input = QLineEdit()
        self.installed_filter_input.setPlaceholderText("Filter installed packages (name or version)...")
        self.installed_filter_input.textChanged.connect(self._filter_installed_list)
        filter_layout.addWidget(self.installed_filter_input)
        layout.addLayout(filter_layout)
        self.installed_package_list = QListWidget()
        self.installed_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.installed_package_list, 1) # Take available space
        button_layout = QHBoxLayout()
        self.add_uninstall_queue_button = QPushButton("Add Selected to Uninstall Queue")
        self.add_uninstall_queue_button.clicked.connect(self.add_installed_to_queue)
        button_layout.addStretch(1)
        button_layout.addWidget(self.add_uninstall_queue_button)
        layout.addLayout(button_layout)
    def _setup_queue_tab(self): # Renamed from _setup_search_tab
        layout = QVBoxLayout(self.queue_tab)
        queue_label = QLabel("Pending Actions (Uncheck items to exclude from Apply):")
        layout.addWidget(queue_label)
        self.queue_list = QListWidget()
        layout.addWidget(self.queue_list, 1) # Take available space
        button_layout = QHBoxLayout()
        self.apply_queue_button = QPushButton("Apply Queued Changes")
        self.apply_queue_button.clicked.connect(self.apply_queue)
        button_layout.addWidget(self.apply_queue_button)
        self.clear_queue_button = QPushButton("Clear Queue")
        self.clear_queue_button.clicked.connect(self.clear_queue)
        button_layout.addWidget(self.clear_queue_button)
        button_layout.addStretch(1)
        layout.addLayout(button_layout)
    def _setup_update_tab(self):
        layout = QVBoxLayout(self.update_tab)
        self.update_package_list = QListWidget()
        self.update_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.update_package_list, 1) # Take available space
        button_layout = QHBoxLayout()
        self.update_selected_queue_button = QPushButton("Add Selected to Update Queue")
        self.update_selected_queue_button.clicked.connect(self.add_updates_to_queue)
        button_layout.addWidget(self.update_selected_queue_button)
        self.update_all_queue_button = QPushButton("Add All Available Updates to Queue")
        self.update_all_queue_button.setToolTip("Adds all packages listed above to the update queue.")
        self.update_all_queue_button.clicked.connect(self.add_update_all_to_queue)
        button_layout.addWidget(self.update_all_queue_button)
        button_layout.addStretch(1)
        layout.addLayout(button_layout)
    def _setup_output_tab(self):
        layout = QVBoxLayout(self.output_tab)
        self.output_console = QTextEdit()
        self.output_console.setReadOnly(True)
        self.output_console.setAcceptRichText(True) # Ensure rich text is accepted for HTML
        self.output_console.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap) # Prevent wrapping for better readability
        layout.addWidget(self.output_console)
    def apply_dark_mode(self):
        dark_palette = QPalette()
        dark_palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.WindowText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Base, QColor(42, 42, 42)) # List/Edit background
        dark_palette.setColor(QPalette.ColorRole.AlternateBase, QColor(66, 66, 66))
        dark_palette.setColor(QPalette.ColorRole.ToolTipBase, Qt.GlobalColor.black)
        dark_palette.setColor(QPalette.ColorRole.ToolTipText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white) # General text
        dark_palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.ButtonText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
        dark_palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218)) # Blue highlight
        dark_palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Highlight, QColor(80, 80, 80))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.HighlightedText, QColor(127, 127, 127))
        app = QApplication.instance()
        if app:
            app.setPalette(dark_palette)
            app.setStyleSheet(f"""
                QMainWindow {{ background-color: {dark_palette.color(QPalette.ColorRole.Window).name()}; }}
                QWidget {{ color: {dark_palette.color(QPalette.ColorRole.WindowText).name()}; }}
                QToolTip {{
                    color: #ffffff; background-color: #2a82da; border: 1px solid white; padding: 2px;
                }}
                QStatusBar {{ background-color: {dark_palette.color(QPalette.ColorRole.Window).name()}; }}
                QStatusBar QLabel {{ color: {dark_palette.color(QPalette.ColorRole.WindowText).name()}; }}
                QProgressBar {{
                    border: 1px solid grey; border-radius: 5px; text-align: center;
                    background-color: #2A2A2A;
                    color: white;
                }}
                QProgressBar::chunk {{
                    background-color: #4287f5;
                    width: 10px; margin: 0.5px;
                }}
                QTreeView, QListWidget {{
                    background-color: {dark_palette.color(QPalette.ColorRole.Base).name()};
                    alternate-background-color: {dark_palette.color(QPalette.ColorRole.AlternateBase).name()};
                    border: 1px solid #444;
                }}
                QTreeView::item:hover, QListWidget::item:hover {{
                    background-color: QColor(60, 60, 60);
                }}
                QTreeView::item:selected, QListWidget::item:selected {{
                    background-color: {dark_palette.color(QPalette.ColorRole.Highlight).name()};
                    color: {dark_palette.color(QPalette.ColorRole.HighlightedText).name()};
                }}
                QListWidget::item {{ padding: 3px; }}
                QTabWidget::pane {{
                    border-top: 2px solid #444;
                    position: absolute; top: -0.5em;
                    background-color: {dark_palette.color(QPalette.ColorRole.Window).name()};
                }}
                QTabWidget::tab-bar {{ alignment: left; }}
                QTabBar::tab {{
                    background: QColor(66, 66, 66); border: 1px solid #444;
                    border-bottom-color: #444;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px; min-width: 8ex; padding: 4px; margin-right: 2px; color: white;
                }}
                QTabBar::tab:selected, QTabBar::tab:hover {{ background: QColor(80, 80, 80); }}
                QTabBar::tab:selected {{
                    border-color: #9B9B9B; border-bottom-color: #444;
                    font-weight: bold;
                    background: QColor(53, 53, 53);
                }}
                QTabBar::tab:!selected {{ margin-top: 2px; }}
                QTextEdit {{
                    background-color: {dark_palette.color(QPalette.ColorRole.Base).name()};
                    color: #E0E0E0;
                    font-family: Monospace;
                    border: 1px solid #444;
                }}
                QLineEdit {{
                    padding: 3px;
                    border: 1px solid #444;
                    background-color: {dark_palette.color(QPalette.ColorRole.Base).name()};
                }}
                QPushButton {{
                    padding: 5px;
                    border: 1px solid #666;
                    border-radius: 3px;
                    background-color: QColor(70, 70, 70);
                }}
                QPushButton:hover {{ background-color: QColor(85, 85, 85); }}
                QPushButton:pressed {{ background-color: QColor(60, 60, 60); }}
                QPushButton:disabled {{ color: #888; background-color: QColor(60, 60, 60); }}
                QSplitter::handle {{ background-color: #666; border: 1px solid #777; }}
                QSplitter::handle:horizontal {{ width: 5px; }}
                QSplitter::handle:vertical {{ height: 5px; }}
                QHeaderView::section {{ background-color: QColor(66, 66, 66); padding: 4px; border: 1px solid #444; }}
            """)
    def start_worker(self, worker, is_action_worker=False):
        if is_action_worker:
            if self.current_action_worker:
                self.show_error("Another critical operation (Apply Queue / Sync) is already in progress.")
                return False # Indicate failure to start
            self.current_action_worker = worker
        self.threadpool.start(worker)
        self.active_workers += 1
        self._update_ui_for_busy_state()
        return True # Indicate successful start
    def _worker_finished(self):
        self.active_workers = max(0, self.active_workers - 1) # Ensure it doesn't go negative
        self._update_ui_for_busy_state()
    def _action_worker_finished(self, operation_name, callback):
        is_cancelled = self.current_action_worker is not None and self.current_action_worker.is_cancelled
        worker_ref = self.current_action_worker # Keep reference before potentially clearing it
        self.current_action_worker = None # Worker is now done
        self._update_ui_for_busy_state() # Update button states based on cleared action worker
        if worker_ref and not is_cancelled:
            self.status_bar.showMessage(f"{operation_name} completed successfully.", 5000)
            self.output_console.append(f"\n{'-'*20}\n{operation_name} finished successfully.")
            if callback:
                try:
                    callback() # Execute the success callback
                except Exception as e:
                    self.show_error(f"Error in {operation_name} finished callback: {e}\n{traceback.format_exc()}")
        elif is_cancelled:
            self.output_console.append(f"\n{'-'*20}\n{operation_name} was cancelled.")
            pass
    def _command_error(self, command_str, error_msg, error_callback=None, is_action_worker=False):
        is_cancel_message = "Operation Cancelled" in error_msg or "Operation Forcefully Cancelled" in error_msg
        if not is_cancel_message:
            self.show_error(f"Operation Failed:\n{error_msg}")
            self.status_bar.showMessage(f"Error: {error_msg.splitlines()[0]}", 8000)
            self.output_console.append(f"\n{'-'*20}\nERROR:\nCommand: {command_str}\n{error_msg}")
        else:
             pass
        if is_action_worker:
             if self.current_action_worker and self.current_action_worker.command_list == command_str.split(): # Basic check
                 self.current_action_worker = None
        if error_callback:
            try:
                error_callback(error_msg) # Execute the specific error callback
            except Exception as e:
                self.show_error(f"Error in error callback: {e}\n{traceback.format_exc()}")
    def _command_progress(self, progress_text):
        if self.ansi_converter:
            html_line = self.ansi_converter.convert(progress_text, full=False)
            self.output_console.moveCursor(QTextCursor.MoveOperation.End)
            self.output_console.insertHtml(html_line + "<br>") # Append as HTML
        else:
            self.output_console.append(progress_text) # Fallback to plain text
        sb = self.output_console.verticalScrollBar()
        sb.setValue(sb.maximum())
    def _update_ui_for_busy_state(self):
        is_general_busy = self.active_workers > 0
        is_action_busy = self.current_action_worker is not None
        self.refresh_button.setEnabled(not is_general_busy)
        self.sync_button.setEnabled(not is_action_busy)
        can_apply = not is_action_busy and self.queue_list.count() > 0 and any(
            self.queue_list.item(i).flags() & Qt.ItemFlag.ItemIsUserCheckable
            for i in range(self.queue_list.count())
        )
        self.apply_queue_button.setEnabled(can_apply)
        self.clear_queue_button.setEnabled(not is_action_busy) # Can clear queue even if list refresh is running
        self.cancel_button.setEnabled(is_action_busy)
        can_modify_queue = not is_action_busy
        self.browse_add_queue_button.setEnabled(can_modify_queue)
        self.add_uninstall_queue_button.setEnabled(can_modify_queue)
        self.update_selected_queue_button.setEnabled(can_modify_queue)
        self.update_all_queue_button.setEnabled(can_modify_queue)
        if is_general_busy and not self.progress_bar.isVisible():
            self.progress_bar.setRange(0,0) # Indeterminate
            self.progress_bar.setVisible(True)
        elif not is_general_busy and self.progress_bar.isVisible():
            self.progress_bar.setVisible(False)
            self.status_bar.clearMessage() # Clear "Running..." message when idle
    def run_action_command(self, command_list, on_success_callback=None, on_error_callback=None, use_pkexec=False, operation_name="Operation"):
        command_str = ' '.join(command_list)
        self.status_bar.showMessage(f"Starting: {operation_name}...")
        self.progress_bar.setRange(0, 0) # Indeterminate
        self.progress_bar.setVisible(True)
        self.tabs.setCurrentWidget(self.output_tab) # Switch to output tab
        self.output_console.clear() # Clear previous output
        self.output_console.append(f"--- Executing ({operation_name}) ---")
        self.output_console.append(f"{'pkexec ' if use_pkexec else ''}{command_str}")
        self.output_console.append(f"{'-'*len(command_str)}\n")
        worker = CommandWorker(command_list, use_pkexec, collect_output=False) # No collected output needed usually
        worker.signals.result.connect(lambda res: None)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err, on_error_callback, is_action_worker=True))
        worker.signals.progress.connect(self._command_progress)
        worker.signals.status_update.connect(self.status_bar.showMessage) # Allow worker to update status
        worker.signals.finished.connect(self._worker_finished) # Generic decrement counter ALWAYS
        worker.signals.finished.connect(lambda: self._action_worker_finished(operation_name, on_success_callback))
        if not self.start_worker(worker, is_action_worker=True):
            self.progress_bar.setVisible(self.active_workers > 0) # Re-evaluate progress bar
            return False # Indicate failure
        return True # Indicate success
    def cancel_action_worker(self):
        if self.current_action_worker:
            self.status_bar.showMessage("Attempting to cancel operation...")
            self.cancel_button.setEnabled(False) # Disable immediately to prevent multi-clicks
            self.current_action_worker.stop()
        else:
            self.status_bar.showMessage("No cancellable operation running.", 3000)
    def get_selected_items_text(self, list_widget):
        items = list_widget.selectedItems()
        return [item.text() for item in items]
    def _filter_list_widget(self, filter_text, list_widget, source_data=None):
        filter_lower = filter_text.lower()
        list_widget.setUpdatesEnabled(False) # Pause updates for performance
        try:
            for i in range(list_widget.count()):
                item = list_widget.item(i)
                if item:
                    item_text = item.text().lower()
                    item.setHidden(filter_lower not in item_text)
        finally:
            list_widget.setUpdatesEnabled(True) # Re-enable updates
    def _filter_browse_list(self, text):
        filter_lower = text.lower()
        selected_category_items = self.category_tree.selectedItems()
        self.browse_package_list.setUpdatesEnabled(False)
        try:
            if not selected_category_items:
                self.browse_package_list.clear() # Clear the list first
                matching_packages = []
                if not filter_lower:
                    pass
                else:
                    for category, packages in self.available_packages_by_cat.items():
                        for pkg_atom in packages: # pkg_atom is "cat/pkg"
                            if filter_lower in pkg_atom.lower():
                                matching_packages.append(pkg_atom)
                self.browse_package_list.addItems(sorted(matching_packages))
            else:
                category = selected_category_items[0].text(0)
                if category in self.available_packages_by_cat:
                    for i in range(self.browse_package_list.count()):
                        item = self.browse_package_list.item(i)
                        if item:
                            item.setHidden(filter_lower not in item.text().lower())
        finally:
            self.browse_package_list.setUpdatesEnabled(True)
    def _filter_installed_list(self, text):
        self._filter_list_widget(text, self.installed_package_list)
    def _add_to_queue(self, package_atom, action_type):
        if not package_atom: return False
        self.pending_actions[package_atom] = action_type
        print(f"Queued: {package_atom} for {action_type}") # Debugging
        self._update_queue_display() # Refresh the visual list
        return True
    def _remove_from_queue(self, package_atom):
        if package_atom in self.pending_actions:
            del self.pending_actions[package_atom]
            print(f"Removed from queue: {package_atom}") # Debugging
            self._update_queue_display() # Refresh the visual list
            return True
        return False
    def _update_queue_display(self):
        self.queue_list.setUpdatesEnabled(False)
        self.queue_list.clear()
        if not self.pending_actions:
            item = QListWidgetItem("Queue is empty.")
            item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsUserCheckable) # Not checkable
            self.queue_list.addItem(item)
        else:
            sorted_atoms = sorted(self.pending_actions.keys())
            action_map = {
                ACTION_INSTALL: "Install",
                ACTION_UNINSTALL: "Uninstall",
                ACTION_UPDATE: "Update"
            }
            color_map = {
                ACTION_INSTALL: QColor("lightblue"),
                ACTION_UNINSTALL: QColor("salmon"),
                ACTION_UPDATE: QColor("lightgreen")
            }
            for atom in sorted_atoms:
                action = self.pending_actions[atom]
                action_text = action_map.get(action, "Unknown Action")
                display_text = f"[{action_text}] {atom}"
                item = QListWidgetItem(display_text)
                item.setData(Qt.ItemDataRole.UserRole, (atom, action)) # Store atom and action
                item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
                item.setCheckState(Qt.CheckState.Checked) # Default to checked
                self.queue_list.addItem(item)
        self.queue_list.setUpdatesEnabled(True)
        self._update_ui_for_busy_state() # Re-evaluate apply button state
    def add_browse_to_queue(self):
        selected_items = self.get_selected_items_text(self.browse_package_list)
        added_count = 0
        skipped_installed = 0
        parsed_count = 0
        for item_text in selected_items:
            atom_match = re.match(r'^([\w-]+(?:/[\w-]+)*/[\w.+-]+)$', item_text)
            if atom_match:
                parsed_count += 1
                atom = atom_match.group(1)
                if atom in self.installed_packages_map:
                    print(f"Skipping install queue for already installed package: {atom}")
                    skipped_installed += 1
                    continue # Skip adding to install queue if present in installed map
                if self._add_to_queue(atom, ACTION_INSTALL):
                    added_count += 1
        if added_count > 0:
            msg = f"Added {added_count} package(s) to install queue."
            if skipped_installed > 0:
                 msg += f" Skipped {skipped_installed} already installed package(s)."
            self.status_bar.showMessage(msg, 4000)
            self.tabs.setCurrentWidget(self.queue_tab) # Switch to queue tab
        elif skipped_installed > 0:
             self.status_bar.showMessage(f"Selected package(s) already installed.", 3000)
        elif parsed_count > 0 :
             self.show_error("Failed to add selected packages to queue.")
        elif selected_items:
             self.show_error("Could not parse selected package names.")
        else:
             self.status_bar.showMessage("No packages selected in the list.", 3000) # Less intrusive than error box
    def add_installed_to_queue(self):
        selected_items = self.get_selected_items_text(self.installed_package_list)
        added_count = 0
        parsed_count = 0
        pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*/[\w.+-]+)-[\d].*')
        for item_text in selected_items:
            match = pattern.match(item_text)
            if match:
                parsed_count += 1
                atom = match.group(1)
                if self._add_to_queue(atom, ACTION_UNINSTALL):
                    added_count += 1
            else:
                print(f"Warning: Could not parse atom from installed package: {item_text}")
        if added_count > 0:
            self.status_bar.showMessage(f"Added {added_count} package(s) to uninstall queue.", 3000)
            self.tabs.setCurrentWidget(self.queue_tab)
        elif parsed_count > 0 :
            self.show_error("Failed to add selected packages to queue.")
        elif selected_items:
            self.show_error("Could not parse selected package names for uninstallation.")
        else:
            self.status_bar.showMessage("No packages selected in the list.", 3000)
    def add_updates_to_queue(self):
        selected_items = self.update_package_list.selectedItems() # Get items, not just text
        added_count = 0
        parsed_count = 0
        for item in selected_items:
            atom = item.data(Qt.ItemDataRole.UserRole) # Atom was stored here
            if atom:
                parsed_count += 1
                if self._add_to_queue(atom, ACTION_UPDATE):
                    added_count += 1
        if added_count > 0:
            self.status_bar.showMessage(f"Added {added_count} package(s) to update queue.", 3000)
            self.tabs.setCurrentWidget(self.queue_tab)
        elif parsed_count > 0:
            self.show_error("Failed to add selected updates to queue.")
        elif len(selected_items)>0: # Check original selection length
            self.show_error("Could not get package names from selection.")
        else:
            self.status_bar.showMessage("No updates selected in the list.", 3000)
    def add_update_all_to_queue(self):
        if not self.update_list:
            if self.update_package_list.count() == 1 and self.update_package_list.item(0).data(Qt.ItemDataRole.UserRole) is None:
                self.status_bar.showMessage("No updates available to add.", 3000)
            else:
                self.show_error("No updates found or list not refreshed.")
            return
        added_count = 0
        for atom in self.update_list:
            if self._add_to_queue(atom, ACTION_UPDATE):
                added_count += 1
        if added_count > 0:
            self.status_bar.showMessage(f"Added all {added_count} available updates to queue.", 3000)
            self.tabs.setCurrentWidget(self.queue_tab)
        else:
            self.show_error("Failed to add updates to queue.")
    def clear_queue(self):
        if self.pending_actions:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Confirm Clear Queue")
            msg_box.setText("Are you sure you want to remove all pending actions from the queue?")
            msg_box.setIcon(QMessageBox.Icon.Question)
            msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            msg_box.setDefaultButton(QMessageBox.StandardButton.No)
            if msg_box.exec() == QMessageBox.StandardButton.Yes:
                self.pending_actions.clear()
                self._update_queue_display()
                self.status_bar.showMessage("Queue cleared.", 3000)
        else:
            self.status_bar.showMessage("Queue is already empty.", 3000)
    def apply_queue(self):
        actions_to_apply = defaultdict(list) # Group by action type
        atoms_in_current_apply = [] # Keep track of atoms being processed in this run
        for i in range(self.queue_list.count()):
            item = self.queue_list.item(i)
            if item and item.flags() & Qt.ItemFlag.ItemIsUserCheckable and item.checkState() == Qt.CheckState.Checked:
                data = item.data(Qt.ItemDataRole.UserRole)
                if data:
                    atom, action_type = data
                    actions_to_apply[action_type].append(atom)
                    atoms_in_current_apply.append(atom) # Track atom for cleanup on success
        if not actions_to_apply:
            self.show_error("No actions checked in the queue to apply.")
            return
        summary = []
        if actions_to_apply[ACTION_INSTALL]:
            summary.append(f"Install: {len(actions_to_apply[ACTION_INSTALL])} package(s)")
        if actions_to_apply[ACTION_UPDATE]:
            summary.append(f"Update: {len(actions_to_apply[ACTION_UPDATE])} package(s)")
        if actions_to_apply[ACTION_UNINSTALL]:
            summary.append(f"Uninstall: {len(actions_to_apply[ACTION_UNINSTALL])} package(s)")
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Apply Changes")
        msg_box.setText("The following actions will be performed for CHECKED items:\n\n" + "\n".join(summary) + "\n\nThis requires root privileges (via pkexec). Continue?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            install_update_list = actions_to_apply[ACTION_INSTALL] + actions_to_apply[ACTION_UPDATE]
            uninstall_list = actions_to_apply[ACTION_UNINSTALL]
            commands = []
            if install_update_list:
                cmd = ['emerge', '--ask=n', '--verbose', '-uND'] + install_update_list
                commands.append({'cmd': cmd, 'op': 'Install/Update'})
            if uninstall_list:
                cmd = ['emerge', '--ask=n', '--verbose', '--unmerge'] + uninstall_list
                commands.append({'cmd': cmd, 'op': 'Uninstall'})
            self._original_atoms_for_cleanup = list(atoms_in_current_apply) # Make a copy
            self._commands_to_run = list(commands) # Make a copy
            self._run_next_queued_command()
    def _run_next_queued_command(self):
        if not self._commands_to_run:
            self._queue_apply_finished()
            return
        command_info = self._commands_to_run.pop(0) # Get and remove first command
        cmd = command_info['cmd']
        op_name = command_info['op']
        success = self.run_action_command(
            cmd,
            on_success_callback=self._run_next_queued_command, # Chain to next command on success
            on_error_callback=self._queue_apply_failed,      # Handle failure
            use_pkexec=True,
            operation_name=f"Apply Queue ({op_name})"
        )
        if not success:
            self._queue_apply_failed("Failed to start worker for queue sequence.")
            self._commands_to_run.insert(0, command_info) # Put it back just in case? Probably better to clear.
            self._commands_to_run = [] # Clear remaining commands
    def _queue_apply_finished(self):
        for atom in self._original_atoms_for_cleanup:
            if atom in self.pending_actions:
                del self.pending_actions[atom]
        self._update_queue_display() # Update the visual queue
        self.refresh_installed_packages()
        self.refresh_updates()
        self._commands_to_run = []
        self._original_atoms_for_cleanup = []
    def _queue_apply_failed(self, error_msg):
        self.status_bar.showMessage("Queue application failed. See Output Console.", 6000)
        self._commands_to_run = []
        self._original_atoms_for_cleanup = []
    def run_sync(self):
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Sync")
        msg_box.setText("This will synchronize the package repositories using 'emerge --sync'.\nThis may take some time and requires root privileges (via pkexec).\n\nContinue?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            self.run_action_command( # Use the action command runner
                ['emerge', '--sync'],
                on_success_callback=self._sync_finished, # Specific callback on success
                use_pkexec=True,
                operation_name="Repository Sync"
            )
    def _sync_finished(self):
        self.refresh_updates() # Refresh updates list after successful sync
    def refresh_all(self):
        if self.active_workers > 0 and self.current_action_worker:
            self.show_error("Cannot refresh while a critical operation (Apply Queue / Sync) is in progress.")
            return
        self.status_bar.showMessage("Refreshing all data lists...")
        self.installed_package_list.setUpdatesEnabled(False)
        self.update_package_list.setUpdatesEnabled(False)
        self.category_tree.setUpdatesEnabled(False)
        self.browse_package_list.setUpdatesEnabled(False)
        self.installed_package_list.clear()
        self.update_package_list.clear()
        self.category_tree.clear()
        self.browse_package_list.clear()
        self.installed_filter_input.clear() # Clear filters
        self.browse_filter_input.clear()
        self.installed_package_list.addItem("Loading installed packages...")
        self.update_package_list.addItem("Checking for updates...")
        self.category_tree.addTopLevelItem(QTreeWidgetItem(["Loading categories..."]))
        self.browse_package_list.addItem("Select a category or use filter...")
        self.installed_package_list.setUpdatesEnabled(True)
        self.update_package_list.setUpdatesEnabled(True)
        self.category_tree.setUpdatesEnabled(True)
        self.browse_package_list.setUpdatesEnabled(True)
        self.installed_packages = []
        self.installed_packages_map = {}
        self.available_packages_by_cat = {}
        self.update_list = []
        self.refresh_installed_packages()
        self.refresh_updates()
        self.load_all_available_packages() # This loads categories too
        self.refresh_disk_space() # This one is usually fast, run directly
    def load_all_available_packages(self):
        self.status_bar.showMessage("Loading available packages list (equery list */*)...")
        worker = CommandWorker(['equery', 'list', '*/*'], collect_output=True)
        worker.signals.result.connect(self._handle_available_packages_result)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err, self._handle_available_packages_error)) # Specific error handler
        worker.signals.finished.connect(self._worker_finished) # Generic finish handler
        self.start_worker(worker) # Not an action worker
    def _handle_available_packages_result(self, output_str):
        try:
            local_available_packages = defaultdict(set) # Use set for efficient adding
            lines = output_str.strip().splitlines()
            package_pattern = re.compile(r'^\s*([\w-]+(?:/[\w-]+)*)/([\w.+-]+)-([\d].*)') # cat/subcat/pkg-ver
            for line in lines:
                if '[ Searching ... ]' in line or '[ Completed ' in line: continue
                if not '/' in line or '-' not in line: continue
                match = package_pattern.match(line.strip())
                if match:
                    category = match.group(1)
                    package_name = match.group(2)
                    full_atom = f"{category}/{package_name}" # Store cat/pkg atom
                    local_available_packages[category].add(full_atom)
            self.available_packages_by_cat = {
                cat: sorted(list(pkgs)) for cat, pkgs in local_available_packages.items()
            }
            self.category_tree.setUpdatesEnabled(False)
            self.category_tree.clear() # Clear "Loading..." item
            sorted_categories = sorted(self.available_packages_by_cat.keys())
            top_level_items = [QTreeWidgetItem([category]) for category in sorted_categories]
            self.category_tree.addTopLevelItems(top_level_items)
            self.category_tree.setUpdatesEnabled(True)
            self.category_tree.header().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
            self.browse_package_list.clear()
            self.browse_filter_input.clear() # Ensure filter is clear
            self.status_bar.showMessage(f"Loaded {sum(len(pkgs) for pkgs in self.available_packages_by_cat.values())} available packages in {len(sorted_categories)} categories.", 5000)
        except Exception as e:
            self.show_error(f"Error parsing available packages list: {e}\n{traceback.format_exc()}")
            self._handle_available_packages_error("Parsing failed.")
    def _handle_available_packages_error(self, error_msg):
        self.status_bar.showMessage("Error loading available packages list.", 5000)
        self.category_tree.clear()
        self.category_tree.addTopLevelItem(QTreeWidgetItem(["Error loading categories"]))
        self.browse_package_list.clear()
        self.browse_package_list.addItem("Error loading packages.")
    def category_selected(self):
        selected_items = self.category_tree.selectedItems()
        self.browse_package_list.setUpdatesEnabled(False)
        self.browse_package_list.clear()
        self.browse_filter_input.setPlaceholderText("Filter packages in selected category...")
        if not selected_items:
             self.browse_filter_input.setPlaceholderText("Filter packages (leave category tree empty to search all)...")
             self._filter_browse_list(self.browse_filter_input.text())
        else:
            category_item = selected_items[0]
            category = category_item.text(0)
            if category in self.available_packages_by_cat:
                packages = self.available_packages_by_cat[category] # Already sorted list of cat/pkg
                self.browse_package_list.addItems(packages)
                self._filter_browse_list(self.browse_filter_input.text())
            else:
                 self.browse_package_list.addItem(f"No packages found for category '{category}'.") # Should not happen often
        self.browse_package_list.setUpdatesEnabled(True)
    def refresh_installed_packages(self):
        self.status_bar.showMessage("Loading installed packages list (equery list -I)...")
        worker = CommandWorker(['equery', 'list', '--installed', '*/*'], collect_output=True)
        worker.signals.result.connect(self._handle_installed_packages_result)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err, self._handle_installed_packages_error))
        worker.signals.finished.connect(self._worker_finished)
        self.start_worker(worker) # Not an action worker
    def _handle_installed_packages_result(self, output_str):
        try:
            lines = output_str.strip().splitlines()
            package_pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*)/([\w.+-]+-[\d].*)') # cat/pkg-ver
            atom_pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*)/([\w.+-]+)-[\d].*')
            local_installed_packages = []
            local_installed_map = {}
            for line in lines:
                 if '[ Searching ... ]' in line or '[ Completed ' in line: continue
                 match = package_pattern.match(line.strip())
                 if match:
                     full_ver_pkg = match.group(0).strip() # Full line match cat/pkg-ver
                     local_installed_packages.append(full_ver_pkg)
                     atom_match = atom_pattern.match(full_ver_pkg)
                     if atom_match:
                         atom = f"{atom_match.group(1)}/{atom_match.group(2)}"
                         local_installed_map[atom] = full_ver_pkg # Map cat/pkg to cat/pkg-ver
            self.installed_packages = sorted(local_installed_packages)
            self.installed_packages_map = local_installed_map
            self.installed_package_list.setUpdatesEnabled(False)
            self.installed_package_list.clear() # Clear "Loading..."
            self.installed_package_list.addItems(self.installed_packages)
            self.installed_package_list.setUpdatesEnabled(True)
            self._filter_installed_list(self.installed_filter_input.text()) # Reapply filter
            self.status_bar.showMessage(f"{len(self.installed_packages)} installed packages loaded.", 5000)
        except Exception as e:
            self.show_error(f"Error parsing installed packages list: {e}\n{traceback.format_exc()}")
            self._handle_installed_packages_error("Parsing failed.")
    def _handle_installed_packages_error(self, error_msg):
        self.status_bar.showMessage("Error loading installed packages list.", 5000)
        self.installed_package_list.clear()
        self.installed_package_list.addItem("Error loading installed packages.")
    def refresh_updates(self):
        self.status_bar.showMessage("Checking for updates (emerge -upvND @world)...")
        command = ['emerge', '--pretend', '--update', '--verbose', '--newuse', '--deep', '@world']
        worker = CommandWorker(command, collect_output=True) # Collect output to parse
        worker.signals.result.connect(self._handle_updates_result)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err, self._handle_updates_error)) # Handles non-zero exit etc.
        worker.signals.finished.connect(self._worker_finished)
        self.start_worker(worker) # Not an action worker
    def _handle_updates_result(self, output_str):
        try:
            local_update_list_atoms = set() # Use set to store unique cat/pkg atoms
            display_items_map = {} # Store display text keyed by atom
            lines = output_str.strip().splitlines()
            update_pattern = re.compile(
                r"\[ebuild\s+(?P<type>[DUNR])(?P<block>[DS]?)\s*]\s+" # Type (Update, New, Downgrade, Rebuild), Block status
                r"(?P<catpkg>[\w-]+(?:/[\w-]+)*/[\w.+-]+)-"          # Category/Package atom (ends before version)
                r"(?P<version>[\d].*?)"                              # Version string (captured lazily)
                r"(?:\s+->\s*(?P<newver>[\d].*?))?"                  # Optional '-> newver' for updates/downgrades
                r"(?:.+USE=\"(?P<use>.*?)\")?"                       # Optional USE flags section (non-greedy match before)
            )
            for line in lines:
                if not line.strip().startswith('[ebuild'): continue
                match = update_pattern.search(line)
                if match:
                    data = match.groupdict()
                    pkg_atom = data['catpkg'] # Actionable item is cat/pkg atom
                    local_update_list_atoms.add(pkg_atom)
                    status = data['type']
                    status_desc = {'U': 'Update', 'N': 'New', 'D': 'Downgrade', 'R': 'Rebuild'}.get(status, status)
                    current_version = data['version'] # Version being acted upon
                    new_version = data['newver']
                    display_text = f"{pkg_atom}"
                    if new_version: # Update or Downgrade
                        installed_ver = self.installed_packages_map.get(pkg_atom, f"{current_version} (?)") # Use parsed version as fallback
                        if installed_ver.startswith(pkg_atom): installed_ver = installed_ver[len(pkg_atom)+1:] # Strip cat/pkg- prefix
                        display_text += f" ({installed_ver} -> {new_version})"
                    else: # New or Rebuild
                        display_text += f" ({status_desc} {current_version})"
                    if data['use']:
                        display_text += f" | USE: {data['use'].strip()}"
                    display_items_map[pkg_atom] = display_text
            self.update_list = sorted(list(local_update_list_atoms)) # Update main data (sorted atoms)
            self.update_package_list.setUpdatesEnabled(False)
            self.update_package_list.clear() # Clear "Loading..." or old items
            if not self.update_list:
                self.status_bar.showMessage("System is up to date.", 5000)
                no_item = QListWidgetItem("No updates available.")
                no_item.setFlags(no_item.flags() & ~Qt.ItemFlag.ItemIsUserCheckable) # Not checkable
                no_item.setData(Qt.ItemDataRole.UserRole, None) # No atom data
                self.update_package_list.addItem(no_item)
            else:
                self.status_bar.showMessage(f"{len(self.update_list)} updates available.", 5000)
                for atom in self.update_list: # Iterate through sorted atoms
                    display_text = display_items_map.get(atom, f"{atom} (Update info missing)")
                    item = QListWidgetItem(display_text)
                    item.setData(Qt.ItemDataRole.UserRole, atom) # Store atom for later use
                    self.update_package_list.addItem(item)
            self.update_package_list.setUpdatesEnabled(True)
        except Exception as e:
            self.show_error(f"Error parsing update check results: {e}\n{traceback.format_exc()}")
            self._handle_updates_error("Parsing failed.")
    def _handle_updates_error(self, error_msg):
        if "emerge --sync" in error_msg:
             self.status_bar.showMessage("Repository sync needed. Run 'Sync Repositories'.", 8000)
             self.update_package_list.clear()
             self.update_package_list.addItem("Run 'Sync Repositories' before checking updates.")
        else:
             self.status_bar.showMessage("Error checking updates.", 5000)
             self.update_package_list.clear()
             self.update_package_list.addItem("Error checking updates. See Output Console.")
    def refresh_disk_space(self):
        try:
            stats = os.statvfs('/')
            total_bytes = stats.f_blocks * stats.f_frsize
            available_bytes = stats.f_bavail * stats.f_frsize
            total_gb = total_bytes / (1024**3)
            available_gb = available_bytes / (1024**3)
            used_gb = total_gb - available_gb
            disk_info = f"Disk (/): {used_gb:.1f}/{total_gb:.1f} GB ({available_gb:.1f} GB Free)"
            self.disk_space_label.setText(disk_info)
        except Exception as e:
            self.disk_space_label.setText("Disk: Error")
            print(f"Error getting disk space: {e}") # Log error
    def show_error(self, message):
        QMessageBox.critical(self, "Error", message)
    def closeEvent(self, event):
        if self.current_action_worker: # Check if a Sync or Apply Queue is running
            reply = QMessageBox.question(self, 'Confirm Exit',
                                         "A critical operation (Apply Queue / Sync) is in progress.\n\nAre you sure you want to exit? The operation will be cancelled.",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                self.status_bar.showMessage("Exiting: Cancelling running operation...")
                self.cancel_action_worker() # Attempt cancellation
                self.threadpool.waitForDone(1000) # Brief wait for signals maybe?
                event.accept()
            else:
                event.ignore() # Prevent closing
                return # Don't proceed to check other workers
        elif self.active_workers > 0: # Check for non-action workers (list refreshes)
            reply = QMessageBox.question(self, 'Confirm Exit',
                                         f"{self.active_workers} background list refresh task(s) are still running.\n\nExit anyway?",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.No:
                event.ignore()
                return
            else:
                print(f"Exiting with {self.active_workers} background tasks still active.")
                self.threadpool.waitForDone(1000) # Wait max 1 sec
                event.accept()
        else: # No workers running
            event.accept()
if __name__ == "__main__":
    if os.geteuid() == 0:
        print("\033[91mWarning:\033[0m Running this GUI directly as root is not recommended.")
        print("Please run as a regular user. Operations requiring privileges will use pkexec.")
        try:
            reply = input("Continue anyway as root? (y/N): ")
        except NameError: # Fallback for very old Python 2 where input() evals
             reply = raw_input("Continue anyway as root? (y/N): ") # type: ignore
        if reply.lower() != 'y':
            sys.exit("Exiting: Please run as a non-root user.")
    if not Ansi2HTMLConverter:
        print("\n\033[93m*** WARNING: 'ansi2html' not found. Install with 'pip install ansi2html' for colored console output in the GUI. ***\033[0m\n")
    app = QApplication(sys.argv)
    main_window = GentooPackageManagerGUI()
    main_window.show()
    sys.exit(app.exec())
