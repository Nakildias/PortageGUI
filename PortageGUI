import sys
import os
import subprocess
import re
import math
import traceback # For better error reporting
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QListWidget, QPushButton, QLineEdit, QLabel,
    QStatusBar, QProgressBar, QMessageBox, QTextEdit, QSplitter,
    QListWidgetItem, QTreeWidget, QTreeWidgetItem, QHeaderView
)
from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QObject, QTimer, QRunnable, QThreadPool
)
from PyQt6.QtGui import QPalette, QColor, QIcon, QTextCursor # Import QIcon, QTextCursor

# --- External Library for ANSI -> HTML ---
try:
    from ansi2html import Ansi2HTMLConverter
except ImportError:
    print("Error: 'ansi2html' library not found. Please install it: pip install ansi2html")
    # Optionally prevent the app from starting or disable color output
    Ansi2HTMLConverter = None # type: ignore

# --- Configuration ---
COMMAND_TIMEOUT = 300  # Timeout for subprocess calls in seconds (e.g., 5 minutes)
REFRESH_INTERVAL = 300000 # Refresh disk space every 5 minutes (in milliseconds)
# Set application icon path (replace with your actual icon path or remove if none)
APP_ICON_PATH = "/usr/share/icons/hicolor/48x48/apps/system-software-install.png" # Example path

# --- Worker Signals ---
class WorkerSignals(QObject):
    finished = pyqtSignal()              # Signal emitted when the worker is done (regardless of success/error)
    error = pyqtSignal(str, str)         # Signal emitted on error (command_str, error_message)
    result = pyqtSignal(object)          # Signal emitted with the result (e.g., command output)
    progress = pyqtSignal(str)           # Signal for text updates (lines of output)
    progress_val = pyqtSignal(int, int)  # For progress bar (current, total) - difficult with emerge
    status_update = pyqtSignal(str)      # For updating status bar message from worker

# --- Base Worker Class for Commands ---
class CommandWorker(QRunnable): # Use QRunnable for QThreadPool compatibility
    def __init__(self, command_list, use_pkexec=False, collect_output=False):
        super().__init__()
        self.command_list = command_list
        self.signals = WorkerSignals()
        self.use_pkexec = use_pkexec
        self.collect_output = collect_output
        self.process = None
        self.is_cancelled = False

    def run(self):
        command_str = ' '.join(self.command_list)
        full_command = self.command_list
        collected_stdout = []

        try:
            if self.use_pkexec:
                if subprocess.run(['which', 'pkexec'], capture_output=True, text=True).returncode != 0:
                    self.signals.error.emit(command_str, "Error: 'pkexec' command not found. Is PolicyKit installed?")
                    self.signals.finished.emit()
                    return
                full_command = ['pkexec', '--disable-internal-agent'] + self.command_list
                command_str = 'pkexec ' + command_str # Update for error reporting

            self.process = subprocess.Popen(
                full_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1, # Line buffered
                errors='replace' # Handle potential decoding errors
            )

            # Stream stdout for progress
            if self.process.stdout:
                for line in iter(self.process.stdout.readline, ''):
                    if self.is_cancelled:
                        break
                    line_strip = line.strip()
                    self.signals.progress.emit(line_strip) # Emit raw line for console
                    if self.collect_output:
                        collected_stdout.append(line_strip) # Store if needed
                self.process.stdout.close()

            if self.is_cancelled:
                 self.signals.error.emit(command_str, "Operation Cancelled")
                 self.signals.finished.emit()
                 return # Don't proceed further if cancelled

            # Wait for the process to finish and get stderr
            stderr_output = ""
            if self.process.stderr:
                stderr_output = self.process.stderr.read()
                self.process.stderr.close()

            # Use poll() first, then wait() with timeout only if necessary
            # This avoids blocking if the process already finished during stdout reading
            return_code = self.process.poll()
            if return_code is None:
                try:
                    self.process.wait(timeout=COMMAND_TIMEOUT)
                    return_code = self.process.returncode
                except subprocess.TimeoutExpired:
                    self.process.kill()
                    self.signals.error.emit(command_str, f"Command timed out after {COMMAND_TIMEOUT} seconds.")
                    self.signals.finished.emit()
                    return
            # else: return_code is already set

            if return_code != 0:
                error_message = f"Command failed with exit code {return_code}.\n"
                error_message += f"Command: {' '.join(full_command)}\n"
                if stderr_output:
                    error_message += f"Stderr:\n{stderr_output.strip()}"
                else:
                    # Check stdout if stderr is empty
                    stdout_for_error = "\n".join(collected_stdout[-10:]) # Last 10 lines might help
                    if stdout_for_error:
                        error_message += f"\nLast Output Lines:\n{stdout_for_error}"
                    else:
                        error_message += "Check console output for details (no specific stderr)."

                # Try to extract common emerge errors
                if "emerge --sync" in command_str:
                    if "are you root?" in stderr_output.lower() or "permission denied" in stderr_output.lower():
                        error_message += "\n\nHint: Sync requires root privileges. Check pkexec configuration or run command manually."
                self.signals.error.emit(command_str, error_message)
            else:
                # Send collected output if requested, otherwise just signal success
                if self.collect_output:
                    self.signals.result.emit("\n".join(collected_stdout))
                else:
                    self.signals.result.emit("Command finished successfully.") # Send generic success

        except FileNotFoundError:
            self.signals.error.emit(command_str, f"Error: Command '{self.command_list[0]}' not found. Is it installed and in PATH?")
        except subprocess.TimeoutExpired: # Should be caught above, but as fallback
             if self.process: self.process.kill()
             self.signals.error.emit(command_str, f"Command timed out unexpectedly.\nCommand: {' '.join(full_command)}")
        except Exception as e:
            self.signals.error.emit(command_str, f"An unexpected error occurred in worker: {e}\nCommand: {' '.join(full_command)}\n{traceback.format_exc()}")
        finally:
            self.signals.finished.emit() # Always emit finished

    def stop(self):
        self.is_cancelled = True
        if self.process and self.process.poll() is None: # Check if process is running
            self.signals.status_update.emit("Attempting graceful process termination...")
            try:
                # Ask pkexec/sudo to terminate the child first if possible (difficult reliably)
                # On Linux, killing the parent (pkexec/sudo) often orphans the child.
                # Sending SIGTERM (-15) is usually better than SIGKILL (-9).
                # Try terminating the whole process group using os.killpg
                pgid = os.getpgid(self.process.pid)
                os.killpg(pgid, 15) # Send SIGTERM to process group
                # self.process.terminate() # SIGTERM to direct process
                try:
                    self.process.wait(timeout=2) # Wait a bit for graceful exit
                    self.signals.status_update.emit("Process terminated.")
                except subprocess.TimeoutExpired:
                    self.signals.status_update.emit("Forcing process termination (kill)...")
                    # self.process.kill() # SIGKILL if terminate didn't work
                    os.killpg(pgid, 9) # Send SIGKILL to process group
            except Exception as e:
                # Fallback if killpg fails (e.g., permissions)
                try:
                    self.process.kill()
                except Exception as ke:
                     self.signals.status_update.emit(f"Could not stop process: {e} / {ke}")


# --- Main Application Window ---
class GentooPackageManagerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gentoo GUI Package Manager")
        self.setGeometry(100, 100, 1000, 700)

        # Set App Icon
        if os.path.exists(APP_ICON_PATH):
            self.setWindowIcon(QIcon(APP_ICON_PATH))

        # --- Thread Pool ---
        self.threadpool = QThreadPool()
        self.active_workers = 0 # Count active workers
        self.current_command_worker = None # Reference to the specific worker handling install/update/sync/uninstall

        # --- Data storage ---
        self.installed_packages = []
        self.available_packages_by_cat = {}
        self.update_list = [] # Stores actionable package atoms (cat/pkg) for updates

        # --- ANSI Converter ---
        self.ansi_converter = Ansi2HTMLConverter(inline=True) if Ansi2HTMLConverter else None

        # --- Setup UI ---
        self.setup_ui()
        self.apply_dark_mode()

        # --- Initial Load (using threads) ---
        self.refresh_installed_packages()
        self.refresh_disk_space() # Initial disk space check (fast, no thread needed)
        self.refresh_updates()    # Check for updates on startup
        # Load available packages lazily or on demand (below runs it on startup)
        self.load_all_available_packages()

        # --- Setup Timer for Disk Space Refresh ---
        self.disk_space_timer = QTimer(self)
        self.disk_space_timer.timeout.connect(self.refresh_disk_space)
        self.disk_space_timer.start(REFRESH_INTERVAL)

    def setup_ui(self):
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)

        # --- Tabs ---
        self.tabs = QTabWidget()
        self.layout.addWidget(self.tabs)

        # Create Tabs
        self.browse_tab = QWidget()
        self.installed_tab = QWidget()
        self.search_tab = QWidget()
        self.update_tab = QWidget()
        self.output_tab = QWidget() # Tab to show command output

        self.tabs.addTab(self.browse_tab, "Browse Packages")
        self.tabs.addTab(self.installed_tab, "Installed Packages")
        self.tabs.addTab(self.search_tab, "Search")
        self.tabs.addTab(self.update_tab, "Updates")
        self.tabs.addTab(self.output_tab, "Output Console")

        # --- Setup Tab Layouts ---
        self._setup_browse_tab()
        self._setup_installed_tab()
        self._setup_search_tab()
        self._setup_update_tab()
        self._setup_output_tab()

        # --- Bottom Bar (Refresh Button, Status Bar, Progress) ---
        self.bottom_bar_layout = QHBoxLayout()
        self.layout.addLayout(self.bottom_bar_layout)

        self.refresh_button = QPushButton("Refresh All Lists")
        self.refresh_button.setToolTip("Reload Installed, Updates, and Available Packages lists.")
        self.refresh_button.clicked.connect(self.refresh_all)
        self.bottom_bar_layout.addWidget(self.refresh_button)

        self.sync_button = QPushButton("Sync Repositories")
        self.sync_button.setToolTip("Run 'emerge --sync' (requires root privileges via pkexec).")
        self.sync_button.clicked.connect(self.run_sync)
        self.bottom_bar_layout.addWidget(self.sync_button)

        self.cancel_button = QPushButton("Cancel Operation")
        self.cancel_button.setToolTip("Attempt to cancel the current install/sync/update/uninstall operation.")
        self.cancel_button.clicked.connect(self.cancel_operation)
        self.cancel_button.setEnabled(False) # Disabled initially
        self.bottom_bar_layout.addWidget(self.cancel_button)

        self.bottom_bar_layout.addStretch(1) # Push status stuff to the right

        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setRange(0, 0) # Indeterminate initially
        self.progress_bar.setVisible(False) # Hide initially
        self.status_bar.addPermanentWidget(self.progress_bar, 1) # Takes stretch space

        self.disk_space_label = QLabel("Disk: ?/? GB")
        self.status_bar.addPermanentWidget(self.disk_space_label)

    def _setup_browse_tab(self):
        layout = QHBoxLayout(self.browse_tab)
        splitter = QSplitter(Qt.Orientation.Horizontal)
        layout.addWidget(splitter)

        # Left side: Categories Tree
        self.category_tree = QTreeWidget()
        self.category_tree.setHeaderLabel("Categories")
        self.category_tree.itemClicked.connect(self.category_selected)
        splitter.addWidget(self.category_tree)

        # Right side: Packages List and Install Button
        right_pane_widget = QWidget()
        right_layout = QVBoxLayout(right_pane_widget)
        splitter.addWidget(right_pane_widget)

        self.browse_package_list = QListWidget()
        self.browse_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        right_layout.addWidget(self.browse_package_list)

        self.browse_install_button = QPushButton("Install Selected")
        self.browse_install_button.clicked.connect(self.install_selected_browse)
        right_layout.addWidget(self.browse_install_button)

        splitter.setSizes([250, 750])

    def _setup_installed_tab(self):
        layout = QVBoxLayout(self.installed_tab)
        self.installed_package_list = QListWidget()
        self.installed_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.installed_package_list)

        button_layout = QHBoxLayout()
        self.uninstall_button = QPushButton("Uninstall Selected")
        self.uninstall_button.clicked.connect(self.uninstall_selected)
        button_layout.addWidget(self.uninstall_button)
        layout.addLayout(button_layout)

    def _setup_search_tab(self):
        layout = QVBoxLayout(self.search_tab)
        search_layout = QHBoxLayout()

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Enter search keyword (package name or description)...")
        self.search_input.returnPressed.connect(self.search_packages) # Allow Enter key
        search_layout.addWidget(self.search_input)

        self.search_button = QPushButton("Search")
        self.search_button.clicked.connect(self.search_packages)
        search_layout.addWidget(self.search_button)

        layout.addLayout(search_layout)

        self.search_results_list = QListWidget()
        self.search_results_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.search_results_list)

        install_button_layout = QHBoxLayout()
        self.search_install_button = QPushButton("Install Selected")
        self.search_install_button.clicked.connect(self.install_selected_search)
        install_button_layout.addWidget(self.search_install_button)
        layout.addLayout(install_button_layout)

    def _setup_update_tab(self):
        layout = QVBoxLayout(self.update_tab)
        self.update_package_list = QListWidget()
        self.update_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.update_package_list)

        button_layout = QHBoxLayout()
        self.update_selected_button = QPushButton("Update Selected")
        self.update_selected_button.clicked.connect(self.update_selected)
        button_layout.addWidget(self.update_selected_button)

        self.update_all_button = QPushButton("Update All (@world)")
        self.update_all_button.clicked.connect(self.update_all)
        button_layout.addWidget(self.update_all_button)

        layout.addLayout(button_layout)

    def _setup_output_tab(self):
        layout = QVBoxLayout(self.output_tab)
        self.output_console = QTextEdit()
        self.output_console.setReadOnly(True)
        self.output_console.setAcceptRichText(True) # Ensure rich text is accepted for HTML
        self.output_console.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap) # Prevent wrapping for better readability
        # Set a monospace font for better alignment if needed
        # from PyQt6.QtGui import QFontDatabase
        # font = QFontDatabase.systemFont(QFontDatabase.SystemFont.FixedFont)
        # self.output_console.setFont(font)
        layout.addWidget(self.output_console)

    def apply_dark_mode(self):
        dark_palette = QPalette()
        # Base Colors
        dark_palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.WindowText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Base, QColor(42, 42, 42))
        dark_palette.setColor(QPalette.ColorRole.AlternateBase, QColor(66, 66, 66))
        dark_palette.setColor(QPalette.ColorRole.ToolTipBase, Qt.GlobalColor.black)
        dark_palette.setColor(QPalette.ColorRole.ToolTipText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.ButtonText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
        # Highlight Colors
        dark_palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.white)
        # Disabled Colors
        dark_palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Highlight, QColor(80, 80, 80))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.HighlightedText, QColor(127, 127, 127))

        app = QApplication.instance()
        app.setPalette(dark_palette)

        # Apply stylesheet
        app.setStyleSheet("""
            QToolTip {
                color: #ffffff; background-color: #2a82da; border: 1px solid white;
            }
            QProgressBar {
                border: 1px solid grey; border-radius: 5px; text-align: center;
                background-color: #2A2A2A; /* Dark background for progress bar */
            }
            QProgressBar::chunk {
                background-color: #4287f5; /* Blue progress chunk */
                width: 10px; margin: 0.5px; /* Optional margin */
            }
            QTreeView::item:hover, QListWidget::item:hover {
                 background-color: QColor(60, 60, 60);
            }
             QTreeView::item:selected, QListWidget::item:selected {
                 background-color: #2a82da; color: white;
            }
            QTabWidget::pane { /* The tab contents area */
                 border-top: 2px solid #C2C7CB; position: absolute; top: -0.5em;
             }
             QTabWidget::tab-bar { alignment: left; }
             QTabBar::tab {
                 background: QColor(66, 66, 66); border: 1px solid #444;
                 border-bottom-color: #C2C7CB; border-top-left-radius: 4px;
                 border-top-right-radius: 4px; min-width: 8ex; padding: 4px; margin-right: 2px;
             }
             QTabBar::tab:selected, QTabBar::tab:hover { background: QColor(80, 80, 80); }
             QTabBar::tab:selected { border-color: #9B9B9B; border-bottom-color: #C2C7CB; }
             QTabBar::tab:!selected { margin-top: 2px; }
             QTextEdit { /* Ensure console matches theme */
                 background-color: #2A2A2A; color: #FFFFFF;
             }
        """)


    # --- Threading and Command Execution ---

    def start_worker(self, worker):
        """Starts a worker in the thread pool and increments counter."""
        self.threadpool.start(worker)
        self.active_workers += 1
        self._update_ui_for_busy_state()

    def _worker_finished(self):
        """Decrements worker count and updates UI when a worker finishes."""
        self.active_workers -= 1
        if self.active_workers <= 0:
            self.active_workers = 0 # Ensure it doesn't go negative
            self.progress_bar.setVisible(False)
            # Only disable cancel if the specific *command* worker is done
            if not self.current_command_worker or not self.current_command_worker.is_cancelled:
                 self.cancel_button.setEnabled(False)

        self._update_ui_for_busy_state()


    def _update_ui_for_busy_state(self):
        """Enable/disable buttons based on whether any workers are active."""
        is_busy = self.active_workers > 0
        # Disable refresh/sync if any worker is active
        self.refresh_button.setEnabled(not is_busy)
        self.sync_button.setEnabled(not is_busy)
        # Enable cancel only if the *specific* command worker is running
        self.cancel_button.setEnabled(self.current_command_worker is not None)

        if is_busy and not self.progress_bar.isVisible():
            self.progress_bar.setRange(0,0) # Indeterminate
            self.progress_bar.setVisible(True)
        elif not is_busy:
            self.progress_bar.setVisible(False)


    def run_command(self, command_list, on_result, on_error_callback=None, on_finished_callback=None, use_pkexec=False, collect_output=False, operation_name="Operation"):
        """
        Runs a command in a background thread using CommandWorker.
        Manages the `current_command_worker` for cancellation.
        """
        if self.current_command_worker:
            self.show_error("Another privileged operation (install/sync/update/uninstall) is already in progress.")
            return

        command_str = ' '.join(command_list)
        self.status_bar.showMessage(f"Starting: {operation_name}...")
        self.progress_bar.setRange(0, 0) # Indeterminate
        self.progress_bar.setVisible(True)
        # self.cancel_button.setEnabled(True) # Handled by _update_ui_for_busy_state
        self.tabs.setCurrentWidget(self.output_tab) # Switch to output tab
        self.output_console.clear() # Clear previous output
        self.output_console.append(f"Executing ({operation_name}): {'pkexec ' if use_pkexec else ''}{command_str}\n{'-'*20}\n")

        worker = CommandWorker(command_list, use_pkexec, collect_output)
        self.current_command_worker = worker # Track this specific worker

        worker.signals.result.connect(on_result)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err, on_error_callback))
        worker.signals.progress.connect(self._command_progress)
        worker.signals.status_update.connect(self.status_bar.showMessage) # Allow worker to update status
        worker.signals.finished.connect(self._worker_finished) # Generic finish handler
        worker.signals.finished.connect(lambda: self._specific_command_finished(operation_name, on_finished_callback)) # Command specific finish

        self.start_worker(worker)

    def _specific_command_finished(self, operation_name, callback):
        """Handles cleanup specific to the main command worker."""
        # This is called *after* _worker_finished
        if self.current_command_worker and not self.current_command_worker.is_cancelled:
            self.status_bar.showMessage(f"{operation_name} completed.", 5000) # Show for 5 seconds
            self.output_console.append(f"\n{'-'*20}\n{operation_name} finished successfully.")
            if callback:
                try:
                    callback() # Execute the success callback
                except Exception as e:
                    self.show_error(f"Error in {operation_name} finished callback: {e}")
        # Clear the reference to the finished/cancelled command worker
        self.current_command_worker = None
        self._update_ui_for_busy_state() # Update button states now that it's definitely finished


    def _command_error(self, command_str, error_msg, callback):
        """Handles errors from any worker."""
        if error_msg != "Operation Cancelled": # Don't show pop-up for user cancellation
            self.show_error(f"Operation Failed:\n{error_msg}")
            self.status_bar.showMessage(f"Error: {error_msg.splitlines()[0]}", 8000) # Show first line of error
            self.output_console.append(f"\n{'-'*20}\nERROR:\nCommand: {command_str}\n{error_msg}")
        else:
            self.status_bar.showMessage("Operation Cancelled", 5000)
            self.output_console.append(f"\n{'-'*20}\nOperation Cancelled by User.")

        # If this error came from the specific command worker, clear the reference
        # Note: This might clear the reference even if the error is from a different worker if unlucky timing.
        # A more robust system would pass the worker instance itself.
        self.current_command_worker = None # Assume the command worker failed or was cancelled

        if callback:
            try:
                callback(error_msg) # Execute the error callback
            except Exception as e:
                 self.show_error(f"Error in error callback: {e}")

        # The _worker_finished signal will still fire, handling progress bar etc.


    def _command_progress(self, progress_text):
        """Handles progress text updates, converting ANSI to HTML."""
        # Append progress text to the output console, converting ANSI codes
        if self.ansi_converter:
            # Convert ANSI to HTML. full=False avoids full HTML doc structure.
            # Need to escape HTML special chars in the original text *before* conversion?
            # ansi2html handles this. Need to add newline manually.
            html_line = self.ansi_converter.convert(progress_text, full=False)
            self.output_console.moveCursor(QTextCursor.MoveOperation.End)
            self.output_console.insertHtml(html_line + "<br>") # Append as HTML with a line break
        else:
            # Fallback if ansi2html is not available
            self.output_console.append(progress_text)

        # Auto-scroll to the bottom
        self.output_console.verticalScrollBar().setValue(self.output_console.verticalScrollBar().maximum())


    def cancel_operation(self):
        """Attempts to cancel the currently running *main* command worker."""
        if self.current_command_worker:
            self.status_bar.showMessage("Attempting to cancel operation...")
            self.cancel_button.setEnabled(False) # Disable immediately
            self.current_command_worker.stop()
            # UI updates (disabling cancel button more permanently, hiding progress bar)
            # are handled by the _command_error or _specific_command_finished slots
            # when the worker signals its completion/cancellation.
        else:
             self.status_bar.showMessage("No cancellable operation running.", 3000)


    def get_selected_items(self, list_widget):
        """Helper to get the text of selected items from a QListWidget."""
        items = list_widget.selectedItems()
        return [item.text() for item in items]

    # --- Specific Actions (Using Threading) ---

    def run_sync(self):
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Sync")
        msg_box.setText("This will synchronize the package repositories using 'emerge --sync'. This may take some time and requires root privileges (via pkexec). Continue?")
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            self.run_command(
                ['emerge', '--sync'],
                on_result=lambda res: None, # Sync doesn't produce a usable result object
                on_error_callback=None, # Use default error handling
                on_finished_callback=self._sync_finished, # Specific callback on success
                use_pkexec=True,
                operation_name="Repository Sync"
            )

    def _sync_finished(self):
        """Called only on successful completion of sync."""
        self.status_bar.showMessage("Sync finished successfully. Refreshing updates list...", 4000)
        self.refresh_updates() # Refresh updates list after successful sync

    def refresh_all(self):
        """Refreshes all data lists using background threads."""
        if self.active_workers > 0:
            self.show_error("Cannot refresh while other operations are in progress.")
            return

        self.status_bar.showMessage("Refreshing all data lists...")
        # Clear existing views immediately for feedback
        self.installed_package_list.clear()
        self.update_package_list.clear()
        self.category_tree.clear()
        self.browse_package_list.clear()
        self.search_results_list.clear()

        # Trigger all refresh actions, they will run in threads
        self.refresh_installed_packages()
        self.refresh_updates()
        self.load_all_available_packages() # This loads categories too
        self.refresh_disk_space() # This one is usually fast, no thread needed

        # Status message will be updated as each task finishes/errors


    def load_all_available_packages(self):
        """Loads categories and all available packages using equery in a thread."""
        self.status_bar.showMessage("Loading available packages list (equery)...")
        self.category_tree.clear() # Clear tree before starting

        worker = CommandWorker(['equery', 'list', '*/*'], collect_output=True)
        # Connect signals to handlers
        worker.signals.result.connect(self._handle_available_packages_result)
        worker.signals.error.connect(self._command_error) # Use generic error handler
        worker.signals.finished.connect(self._worker_finished) # Use generic finish handler
        # No progress needed here, just final result

        self.start_worker(worker)

    def _handle_available_packages_result(self, output_str):
        """Parses the output of 'equery list */*' and populates the category tree."""
        try:
            self.available_packages_by_cat = {}
            lines = output_str.strip().splitlines()
            cat_items = {} # Temporary dict to hold tree items for sorting

            for line in lines:
                if '[ Searching ... ]' in line or '[ Completed' in line: # Skip equery status lines
                    continue
                # Improved regex to handle package names with hyphens and numbers correctly
                match = re.match(r'^\s*([\w-]+(?:/[\w-]+)*)/([\w.+-]+)-([\d].*)', line.strip()) # cat/subcat/pkg-ver
                if match:
                    category = match.group(1)
                    package_name = match.group(2)
                    # version = match.group(3) # We don't strictly need version here
                    full_name = f"{category}/{package_name}"

                    if category not in self.available_packages_by_cat:
                        self.available_packages_by_cat[category] = set() # Use set for uniqueness
                        # Don't add to tree immediately, sort later
                    self.available_packages_by_cat[category].add(full_name)

            # --- Populate Tree AFTER parsing all ---
            self.category_tree.clear() # Clear again just in case
            sorted_categories = sorted(self.available_packages_by_cat.keys())
            top_level_items = []
            for category in sorted_categories:
                 cat_item = QTreeWidgetItem([category]) # Don't add to tree yet
                 top_level_items.append(cat_item)
                 # Convert set back to sorted list for display later
                 self.available_packages_by_cat[category] = sorted(list(self.available_packages_by_cat[category]))

            self.category_tree.addTopLevelItems(top_level_items) # Add sorted items at once
            # self.category_tree.sortItems(0, Qt.SortOrder.AscendingOrder) # Already sorted

            self.status_bar.showMessage("Available packages list loaded.", 5000)

        except Exception as e:
            self.show_error(f"Error parsing available packages list: {e}\n{traceback.format_exc()}")
            self.status_bar.showMessage("Error loading available packages list.", 5000)


    def category_selected(self, item, column):
        """Populates the browse list when a category is clicked."""
        category = item.text(column)
        self.browse_package_list.clear()
        if category in self.available_packages_by_cat:
            packages = self.available_packages_by_cat[category] # Already sorted list
            self.browse_package_list.addItems(packages)
        # Could add handling for sub-categories if tree structure was deeper


    def refresh_installed_packages(self):
        """Refreshes the installed packages list using equery in a thread."""
        self.status_bar.showMessage("Loading installed packages list (equery)...")
        self.installed_package_list.clear()

        worker = CommandWorker(['equery', 'list', '--installed', '*/*'], collect_output=True)
        worker.signals.result.connect(self._handle_installed_packages_result)
        worker.signals.error.connect(self._command_error)
        worker.signals.finished.connect(self._worker_finished)

        self.start_worker(worker)

    def _handle_installed_packages_result(self, output_str):
        """Parses 'equery list --installed' output and updates the list widget."""
        try:
            lines = output_str.strip().splitlines()
             # Filter out status lines and ensure basic format cat/pkg-ver
            package_pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*/[\w.+-]+-\d.*)')
            self.installed_packages = sorted([
                match.group(1) for line in lines
                if (match := package_pattern.match(line.strip()))
            ])
            self.installed_package_list.clear()
            self.installed_package_list.addItems(self.installed_packages)
            self.status_bar.showMessage(f"{len(self.installed_packages)} installed packages loaded.", 5000)
        except Exception as e:
            self.show_error(f"Error parsing installed packages list: {e}\n{traceback.format_exc()}")
            self.status_bar.showMessage("Error loading installed packages list.", 5000)


    def refresh_updates(self):
        """Checks for updates using 'emerge -upvND @world' in a thread."""
        self.status_bar.showMessage("Checking for updates (emerge)...")
        self.update_package_list.clear()

        # No pkexec needed for checking usually, but may depend on setup.
        # Add use_pkexec=True if permission errors occur for regular users.
        command = ['emerge', '-upvND', '@world'] # pretend, verbose, update, newuse, deep
        worker = CommandWorker(command, collect_output=True) # Collect output to parse
        worker.signals.result.connect(self._handle_updates_result)
        worker.signals.error.connect(self._command_error) # Handles non-zero exit code etc.
        worker.signals.finished.connect(self._worker_finished)

        self.start_worker(worker)

    def _handle_updates_result(self, output_str):
        """Parses 'emerge -upvND' output and populates the updates list."""
        try:
            self.update_list = [] # Clear actionable atoms list
            self.update_package_list.clear()
            lines = output_str.strip().splitlines()

            # Regex looking for lines indicating updates or new installs:
            # [ebuild U ] sys-kernel/gentoo-sources-6.1.12 -> 6.1.16 [6.1.9]
            # [ebuild N ] dev-python/requests-2.28.2
            # [ebuild R ] media-libs/libpng-1.6.39 (Rebuild)
            update_pattern = re.compile(
                r"\[ebuild\s+(?P<type>[DUNR])(?P<block>[DS]?)\s*]\s+" # Type (Update, New, Downgrade, Rebuild), Block status
                r"(?P<catpkg>[\w-]+(?:/[\w-]+)*/[\w.+-]+)-"           # Category/Package name part
                r"(?P<oldver>[\d].*?)"                                # Old version part
                r"(?:\s+->\s*(?P<newver>[\d].*?))?"                   # Optional new version part (for U/D)
                r"(?:\s+\[.*\])?"                                     # Optional other versions part
                r"(?:\s+USE=\"(?P<use>.*?)\")?"                       # Optional USE flags part
                # Add more fields if needed (repo, size, etc.)
            )

            found_updates = []
            for line in lines:
                match = update_pattern.search(line)
                if match:
                    data = match.groupdict()
                    pkg_atom = data['catpkg'] # Actionable item is category/package
                    display_text = f"{pkg_atom}"
                    status = data['type']
                    status_desc = {'U': 'Update', 'N': 'New', 'D': 'Downgrade', 'R': 'Rebuild'}.get(status, status)

                    if data['newver']:
                        display_text += f" (Update to {data['newver']})"
                    else:
                         display_text += f" ({status_desc} - {data['oldver']})" # Show version for New/Rebuild

                    # Add USE flags info if present
                    if data['use']:
                         display_text += f" USE: {data['use']}"

                    if pkg_atom not in self.update_list: # Avoid duplicates if listed multiple times
                        self.update_list.append(pkg_atom)
                        found_updates.append(display_text) # Add display text to list

            if not found_updates:
                 self.status_bar.showMessage("System is up to date.", 5000)
                 self.update_package_list.addItem("No updates available.")
            else:
                 self.status_bar.showMessage(f"{len(self.update_list)} updates available.", 5000)
                 self.update_package_list.addItems(sorted(found_updates))

        except Exception as e:
            self.show_error(f"Error parsing update check results: {e}\n{traceback.format_exc()}")
            self.status_bar.showMessage("Error checking updates.", 5000)


    def search_packages(self):
        """Searches for packages using 'emerge --search --searchdesc' in a thread."""
        keyword = self.search_input.text().strip()
        if not keyword:
            self.show_error("Please enter a search keyword.")
            return

        self.status_bar.showMessage(f"Searching for '{keyword}'...")
        self.search_results_list.clear()

        command = ['emerge', '--search', '--searchdesc', keyword]
        worker = CommandWorker(command, collect_output=True)
        worker.signals.result.connect(lambda output: self._handle_search_result(output, keyword))
        worker.signals.error.connect(self._command_error)
        worker.signals.finished.connect(self._worker_finished)

        self.start_worker(worker)

    def _handle_search_result(self, output_str, keyword):
        """Parses 'emerge --search' output and populates the results list."""
        try:
            results = []
            package_pattern = re.compile(r"^\*\s+([\w-]+(?:/[\w-]+)*/[\w+-]+)\s*") # Start of line, *, space, cat/pkg (no version)
            lines = output_str.strip().splitlines()
            current_package = None
            description = ""

            for line in lines:
                match = package_pattern.match(line)
                if match:
                    # If we were accumulating a description, add the previous package
                    if current_package:
                        results.append(f"{current_package} - {description.strip()}")

                    # Start new package
                    current_package = match.group(1)
                    description = line[match.end():].strip() # Get rest of line as start of description
                elif current_package and line.startswith(' '): # Indented line is part of description
                    description += " " + line.strip()

            # Add the last package found
            if current_package:
                 results.append(f"{current_package} - {description.strip()}")


            self.search_results_list.clear()
            if not results:
                self.status_bar.showMessage(f"No packages found matching '{keyword}'.", 5000)
                self.search_results_list.addItem(f"No results for '{keyword}'.")
            else:
                self.status_bar.showMessage(f"{len(results)} potential matches found for '{keyword}'.", 5000)
                self.search_results_list.addItems(sorted(list(set(results)))) # Use set to remove duplicates

        except Exception as e:
            self.show_error(f"Error parsing search results: {e}\n{traceback.format_exc()}")
            self.status_bar.showMessage(f"Error during search for '{keyword}'.", 5000)

    # --- Install/Uninstall/Update Actions ---

    def _install_packages(self, packages_to_install):
        """Handles the process of installing selected packages."""
        if not packages_to_install:
            self.show_error("No packages selected to install.")
            return

        # Clean package names (remove descriptions, ensure format)
        cleaned_packages = []
        for pkg in packages_to_install:
            match = re.match(r'([\w-]+(?:/[\w-]+)*/[\w+-]+)', pkg) # Extract cat/pkg part
            if match:
                cleaned_packages.append(match.group(1))

        if not cleaned_packages:
             self.show_error("Could not identify valid package names from selection.")
             return

        package_str = " ".join(cleaned_packages)
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Installation")
        msg_box.setText(f"The following packages will be installed:\n\n{package_str}\n\nThis requires root privileges (via pkexec). Dependencies will be pulled automatically. Continue?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            # Use --verbose for more output, --ask=n assumes pkexec handles auth
            command = ['emerge', '--ask=n', '--verbose'] + cleaned_packages
            self.run_command(
                command,
                on_result=lambda res: None, # No specific result parsing needed
                on_error_callback=None,
                on_finished_callback=self._install_finished, # Refresh lists on success
                use_pkexec=True,
                operation_name="Package Installation"
            )

    def _install_finished(self):
        """Called after successful installation."""
        self.status_bar.showMessage("Installation finished. Refreshing lists...", 4000)
        self.refresh_installed_packages()
        self.refresh_updates() # Check if installed packages resolved update needs

    def install_selected_browse(self):
        selected_packages = self.get_selected_items(self.browse_package_list)
        self._install_packages(selected_packages)

    def install_selected_search(self):
        selected_packages = self.get_selected_items(self.search_results_list)
        # Need to extract just the cat/pkg from "cat/pkg - description"
        packages_atoms = [re.match(r'([\w-]+(?:/[\w-]+)*/[\w+-]+)', item).group(1)
                          for item in selected_packages
                          if re.match(r'([\w-]+(?:/[\w-]+)*/[\w+-]+)', item)]
        self._install_packages(packages_atoms)


    def uninstall_selected(self):
        selected_items = self.get_selected_items(self.installed_package_list)
        if not selected_items:
            self.show_error("No packages selected to uninstall.")
            return

        # Extract package atoms (cat/pkg) without the version from the list items
        # Input format is likely 'category/package-version'
        packages_to_uninstall = []
        pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*/[\w.+-]+)-[\d].*')
        for item in selected_items:
            match = pattern.match(item)
            if match:
                packages_to_uninstall.append(match.group(1))
            else:
                print(f"Warning: Could not parse package atom from '{item}', attempting to use as is.")
                packages_to_uninstall.append(item) # Fallback, might fail

        if not packages_to_uninstall:
            self.show_error("Could not parse any package names for uninstallation.")
            return

        package_str = " ".join(packages_to_uninstall)
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Uninstallation")
        # Explain the process clearly
        msg_box.setText(f"The following packages will be uninstalled:\n\n{package_str}\n\n"
                        "This uses 'emerge --unmerge' (requires root via pkexec). "
                        "Orphaned dependencies might remain. Run 'emerge --depclean' separately afterwards to remove them if desired.\n\n"
                        "Continue with unmerge?")
        msg_box.setIcon(QMessageBox.Icon.Warning)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            command = ['emerge', '--ask=n', '--verbose', '--unmerge'] + packages_to_uninstall
            self.run_command(
                command,
                on_result=lambda res: None,
                on_error_callback=None,
                on_finished_callback=self._uninstall_finished,
                use_pkexec=True,
                operation_name="Package Uninstallation"
            )

    def _uninstall_finished(self):
        """Called after successful uninstallation."""
        self.status_bar.showMessage("Uninstallation finished. Refreshing lists...", 4000)
        # Ask user if they want to run depclean now? Maybe too complex.
        # QMessageBox.information(self, "Depclean Recommended", "Uninstallation complete. Consider running 'emerge --depclean' to remove orphaned dependencies.")
        self.refresh_installed_packages()
        self.refresh_updates()


    def update_selected(self):
        """Updates only the packages selected in the Updates tab."""
        selected_items = self.update_package_list.selectedItems()
        if not selected_items:
            self.show_error("No updates selected.")
            return

        # Extract package atoms (cat/pkg) from the display text
        packages_to_update = []
        pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*/[\w+-]+)') # Match cat/pkg at the start
        for item in selected_items:
            text = item.text()
            match = pattern.match(text)
            if match:
                packages_to_update.append(match.group(1))

        if not packages_to_update:
            self.show_error("Could not parse package names from selection.")
            return

        self._perform_update(packages_to_update, "Selected Package Update")

    def update_all(self):
        """Updates all packages (@world)."""
        if not self.update_list: # Check the internal list of atoms
            self.show_error("No updates available or list not refreshed.")
            return
        # Perform update using @world target
        self._perform_update(['@world'], "System Update (@world)")

    def _perform_update(self, packages_or_world, operation_name):
        """Executes the emerge command for updating."""
        package_str = " ".join(packages_or_world)
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Update")
        msg_box.setText(f"The following target(s) will be updated:\n\n{package_str}\n\nThis uses 'emerge -uND' (update, newuse, deep). Requires root privileges (via pkexec). Continue?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            command = ['emerge', '--ask=n', '--verbose', '-uND'] + packages_or_world
            self.run_command(
                command,
                on_result=lambda res: None,
                on_error_callback=None,
                on_finished_callback=self._update_finished,
                use_pkexec=True,
                operation_name=operation_name
            )

    def _update_finished(self):
        """Called after successful update."""
        self.status_bar.showMessage("Update finished. Refreshing lists...", 4000)
        self.refresh_installed_packages()
        self.refresh_updates() # Refresh updates list


    def refresh_disk_space(self):
        """Refreshes the disk space label (runs in main thread, usually fast)."""
        try:
            stats = os.statvfs('/')
            total_bytes = stats.f_blocks * stats.f_frsize
            available_bytes = stats.f_bavail * stats.f_frsize
            total_gb = total_bytes / (1024**3)
            available_gb = available_bytes / (1024**3)
            used_gb = total_gb - available_gb
            disk_info = f"Disk (/): {used_gb:.1f}/{total_gb:.1f} GB ({available_gb:.1f} GB Free)"
            self.disk_space_label.setText(disk_info)
        except Exception as e:
            self.disk_space_label.setText("Disk: Error")
            print(f"Error getting disk space: {e}") # Log error


    # --- Utility Functions ---
    def show_error(self, message):
        """Shows a critical error message box."""
        # Ensure this runs in the main thread if called from a worker (using signals is preferred)
        QMessageBox.critical(self, "Error", message)

    def closeEvent(self, event):
        """Handles the window close event, ensuring workers are stopped."""
        if self.current_command_worker: # Check if a cancellable operation is running
            reply = QMessageBox.question(self, 'Confirm Exit',
                                         "An operation (install/sync/update/uninstall) is in progress. Are you sure you want to exit? The operation will be cancelled.",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)

            if reply == QMessageBox.StandardButton.Yes:
                self.status_bar.showMessage("Exiting: Cancelling running operation...")
                self.cancel_operation()
                # Wait briefly for worker cancellation signal processing? Maybe not needed.
                # self.threadpool.waitForDone(1000) # Wait up to 1 sec for pool (might be too short)
                event.accept() # Allow window to close
            else:
                event.ignore() # Prevent window from closing
        else:
             # Check if *any* worker is active (e.g., list refresh)
             if self.active_workers > 0:
                  reply = QMessageBox.question(self, 'Confirm Exit',
                                         f"{self.active_workers} background task(s) (e.g., list refresh) are running. Exit anyway?",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
                  if reply == QMessageBox.StandardButton.No:
                      event.ignore()
                      return
                  # If Yes, try to cancel them? QThreadPool doesn't directly support cancelling QRunnables easily.
                  # Just accept the exit. The threads might finish abruptly.
                  print(f"Exiting with {self.active_workers} background tasks still active.")
                  event.accept()

             else:
                event.accept() # No critical or background tasks running


# --- Main Execution ---
if __name__ == "__main__":
    if os.geteuid() == 0:
        print("Warning: Running this GUI directly as root is not recommended.")
        print("Please run as a regular user. Operations requiring privileges will use pkexec.")
        # Consider exiting if running as root:
        # reply = input("Continue anyway? (y/N): ")
        # if reply.lower() != 'y':
        #     sys.exit("Exiting: Please run as a non-root user.")

    if not Ansi2HTMLConverter:
         print("\n*** WARNING: 'ansi2html' not found. Console output will not be colored. ***\n")

    app = QApplication(sys.argv)
    main_window = GentooPackageManagerGUI()
    main_window.show()
    sys.exit(app.exec())
