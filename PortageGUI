import sys
import os
import subprocess
import re
import math
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QListWidget, QPushButton, QLineEdit, QLabel,
    QStatusBar, QProgressBar, QMessageBox, QTextEdit, QSplitter,
    QListWidgetItem, QTreeWidget, QTreeWidgetItem, QHeaderView
)
from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QObject, QTimer
)
from PyQt6.QtGui import QPalette, QColor, QIcon  # Import QIcon

# --- Configuration ---
COMMAND_TIMEOUT = 300  # Timeout for subprocess calls in seconds (e.g., 5 minutes)
REFRESH_INTERVAL = 300000 # Refresh disk space every 5 minutes (in milliseconds)
# Set application icon path (replace with your actual icon path or remove if none)
APP_ICON_PATH = "/usr/share/icons/hicolor/48x48/apps/system-software-install.png" # Example path

# --- Worker Signals ---
class WorkerSignals(QObject):
    finished = pyqtSignal()
    error = pyqtSignal(str)
    result = pyqtSignal(object)
    progress = pyqtSignal(str) # For text updates
    progress_val = pyqtSignal(int, int) # For progress bar (current, total) - difficult with emerge

# --- Worker Base Class ---
class CommandWorker(QThread):
    def __init__(self, command_list, use_pkexec=False):
        super().__init__()
        self.command_list = command_list
        self.signals = WorkerSignals()
        self.use_pkexec = use_pkexec
        self.process = None

    def run(self):
        try:
            full_command = self.command_list
            if self.use_pkexec:
                # Check if pkexec exists
                if subprocess.run(['which', 'pkexec'], capture_output=True, text=True).returncode != 0:
                    self.signals.error.emit("Error: 'pkexec' command not found. Is PolicyKit installed?")
                    return
                full_command = ['pkexec', '--disable-internal-agent'] + self.command_list # Use external agent for password prompt

            # Use Popen for potentially long-running processes and streaming output
            self.process = subprocess.Popen(
                full_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1, # Line buffered
                errors='replace' # Handle potential decoding errors
            )

            # Stream stdout for progress
            if self.process.stdout:
                for line in iter(self.process.stdout.readline, ''):
                    self.signals.progress.emit(line.strip())
                self.process.stdout.close()

            # Wait for the process to finish and get stderr
            stderr_output = ""
            if self.process.stderr:
                 stderr_output = self.process.stderr.read()
                 self.process.stderr.close()

            self.process.wait(timeout=COMMAND_TIMEOUT) # Wait with timeout

            if self.process.returncode != 0:
                error_message = f"Command failed with exit code {self.process.returncode}.\n"
                error_message += f"Command: {' '.join(full_command)}\n"
                if stderr_output:
                    error_message += f"Stderr:\n{stderr_output.strip()}"
                else:
                    # Sometimes emerge errors go to stdout when pkexec is used
                     error_message += "Check console output for details."

                # Try to extract common emerge errors
                if "emerge --sync" in stderr_output or "emerge --sync" in "".join(list(iter(self.process.stdout.readline, '')) if self.process.stdout else []): # Check stdout too
                     if "are you root?" in stderr_output.lower():
                         error_message += "\n\nHint: Sync requires root privileges. Check pkexec configuration."
                self.signals.error.emit(error_message)
            else:
                # Send combined output if needed, otherwise just signal finished
                # For simplicity, we often parse specific commands elsewhere
                # and just use 'finished' here.
                 self.signals.result.emit("Command finished successfully.") # Or specific result
                 self.signals.finished.emit()


        except FileNotFoundError:
             self.signals.error.emit(f"Error: Command '{self.command_list[0]}' not found. Is it installed and in PATH?")
        except subprocess.TimeoutExpired:
             self.process.kill()
             self.signals.error.emit(f"Command timed out after {COMMAND_TIMEOUT} seconds.\nCommand: {' '.join(full_command)}")
        except Exception as e:
             self.signals.error.emit(f"An unexpected error occurred: {e}\nCommand: {' '.join(full_command)}")
        finally:
            # No need to emit finished if error occurred, but good practice
            if not self.signals.error._slots: # Check if error signal was emitted
                 self.signals.finished.emit()

    def stop(self):
        if self.process and self.process.poll() is None: # Check if process is running
            try:
                # Ask pkexec/sudo to terminate the child
                subprocess.run(['pkill', '-P', str(self.process.pid)])
                self.process.terminate() # Try graceful termination first
                try:
                    self.process.wait(timeout=2) # Wait a bit
                except subprocess.TimeoutExpired:
                    self.process.kill() # Force kill if necessary
                self.signals.progress.emit("Operation cancelled by user.")
                self.signals.error.emit("Operation Cancelled") # Use error signal to stop progress bar etc.
            except Exception as e:
                 self.signals.progress.emit(f"Could not stop process: {e}")


# --- Main Application Window ---
class GentooPackageManagerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gentoo GUI Package Manager")
        self.setGeometry(100, 100, 1000, 700)

        # Set App Icon
        if os.path.exists(APP_ICON_PATH):
             self.setWindowIcon(QIcon(APP_ICON_PATH))

        # --- Data storage ---
        self.installed_packages = []
        self.available_packages_by_cat = {}
        self.update_list = []
        self.current_worker = None

        # --- Setup UI ---
        self.setup_ui()
        self.apply_dark_mode()

        # --- Initial Load ---
        self.refresh_installed_packages()
        self.refresh_disk_space() # Initial disk space check
        # Optionally load all available packages on startup (can be slow)
        # self.load_all_available_packages()

        # --- Setup Timer for Disk Space Refresh ---
        self.disk_space_timer = QTimer(self)
        self.disk_space_timer.timeout.connect(self.refresh_disk_space)
        self.disk_space_timer.start(REFRESH_INTERVAL)

    def setup_ui(self):
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)

        # --- Tabs ---
        self.tabs = QTabWidget()
        self.layout.addWidget(self.tabs)

        # Create Tabs
        self.browse_tab = QWidget()
        self.installed_tab = QWidget()
        self.search_tab = QWidget()
        self.update_tab = QWidget()
        self.output_tab = QWidget() # Tab to show command output

        self.tabs.addTab(self.browse_tab, "Browse Packages")
        self.tabs.addTab(self.installed_tab, "Installed Packages")
        self.tabs.addTab(self.search_tab, "Search")
        self.tabs.addTab(self.update_tab, "Updates")
        self.tabs.addTab(self.output_tab, "Output Console")

        # --- Setup Tab Layouts ---
        self._setup_browse_tab()
        self._setup_installed_tab()
        self._setup_search_tab()
        self._setup_update_tab()
        self._setup_output_tab()

        # --- Bottom Bar (Refresh Button, Status Bar, Progress) ---
        self.bottom_bar_layout = QHBoxLayout()
        self.layout.addLayout(self.bottom_bar_layout)

        self.refresh_button = QPushButton("Refresh All")
        self.refresh_button.clicked.connect(self.refresh_all)
        self.bottom_bar_layout.addWidget(self.refresh_button)

        self.sync_button = QPushButton("Sync Repositories")
        self.sync_button.clicked.connect(self.run_sync)
        self.bottom_bar_layout.addWidget(self.sync_button)

        self.cancel_button = QPushButton("Cancel Operation")
        self.cancel_button.clicked.connect(self.cancel_operation)
        self.cancel_button.setEnabled(False) # Disabled initially
        self.bottom_bar_layout.addWidget(self.cancel_button)


        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setRange(0, 0) # Indeterminate initially
        self.progress_bar.setVisible(False) # Hide initially
        self.status_bar.addPermanentWidget(self.progress_bar, 1) # Takes stretch space

        self.disk_space_label = QLabel("Disk: ?/? GB")
        self.status_bar.addPermanentWidget(self.disk_space_label)

    def _setup_browse_tab(self):
        layout = QHBoxLayout(self.browse_tab)
        splitter = QSplitter(Qt.Orientation.Horizontal)
        layout.addWidget(splitter)

        # Left side: Categories Tree
        self.category_tree = QTreeWidget()
        self.category_tree.setHeaderLabel("Categories")
        self.category_tree.itemClicked.connect(self.category_selected)
        splitter.addWidget(self.category_tree)

        # Right side: Packages List and Install Button
        right_pane_widget = QWidget()
        right_layout = QVBoxLayout(right_pane_widget)
        splitter.addWidget(right_pane_widget)

        self.browse_package_list = QListWidget()
        self.browse_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        right_layout.addWidget(self.browse_package_list)

        self.browse_install_button = QPushButton("Install Selected")
        self.browse_install_button.clicked.connect(self.install_selected_browse)
        right_layout.addWidget(self.browse_install_button)

        # Set initial sizes for splitter
        splitter.setSizes([250, 750])

    def _setup_installed_tab(self):
        layout = QVBoxLayout(self.installed_tab)
        self.installed_package_list = QListWidget()
        self.installed_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.installed_package_list)

        button_layout = QHBoxLayout()
        self.uninstall_button = QPushButton("Uninstall Selected")
        self.uninstall_button.clicked.connect(self.uninstall_selected)
        button_layout.addWidget(self.uninstall_button)
        layout.addLayout(button_layout)

    def _setup_search_tab(self):
        layout = QVBoxLayout(self.search_tab)
        search_layout = QHBoxLayout()

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Enter search keyword (package name or description)...")
        self.search_input.returnPressed.connect(self.search_packages) # Allow Enter key
        search_layout.addWidget(self.search_input)

        self.search_button = QPushButton("Search")
        self.search_button.clicked.connect(self.search_packages)
        search_layout.addWidget(self.search_button)

        layout.addLayout(search_layout)

        self.search_results_list = QListWidget()
        self.search_results_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.search_results_list)

        install_button_layout = QHBoxLayout()
        self.search_install_button = QPushButton("Install Selected")
        self.search_install_button.clicked.connect(self.install_selected_search)
        install_button_layout.addWidget(self.search_install_button)
        layout.addLayout(install_button_layout)


    def _setup_update_tab(self):
        layout = QVBoxLayout(self.update_tab)
        self.update_package_list = QListWidget()
        self.update_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.update_package_list)

        button_layout = QHBoxLayout()
        self.update_selected_button = QPushButton("Update Selected")
        self.update_selected_button.clicked.connect(self.update_selected)
        button_layout.addWidget(self.update_selected_button)

        self.update_all_button = QPushButton("Update All")
        self.update_all_button.clicked.connect(self.update_all)
        button_layout.addWidget(self.update_all_button)

        layout.addLayout(button_layout)

    def _setup_output_tab(self):
        layout = QVBoxLayout(self.output_tab)
        self.output_console = QTextEdit()
        self.output_console.setReadOnly(True)
        self.output_console.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap) # Prevent wrapping for better readability
        layout.addWidget(self.output_console)

    # --- Styling ---
    def apply_dark_mode(self):
        dark_palette = QPalette()

        # Base Colors
        dark_palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.WindowText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Base, QColor(42, 42, 42)) # Input fields, list backgrounds
        dark_palette.setColor(QPalette.ColorRole.AlternateBase, QColor(66, 66, 66)) # Alternating rows (if applicable)
        dark_palette.setColor(QPalette.ColorRole.ToolTipBase, Qt.GlobalColor.black)
        dark_palette.setColor(QPalette.ColorRole.ToolTipText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white) # General text
        dark_palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.ButtonText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red) # Often used for highlighting errors

        # Highlight Colors
        dark_palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218)) # Blue highlight
        dark_palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.white)

        # Disabled Colors
        dark_palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(127, 127, 127)) # Placeholder text in LineEdit
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Highlight, QColor(80, 80, 80))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.HighlightedText, QColor(127, 127, 127))


        app = QApplication.instance()
        app.setPalette(dark_palette)

        # Optional: Apply stylesheet for more control (like progress bar styling)
        app.setStyleSheet("""
            QToolTip {
                color: #ffffff;
                background-color: #2a82da;
                border: 1px solid white;
            }
            QProgressBar {
                border: 1px solid grey;
                border-radius: 5px;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #4287f5; /* Blue progress chunk */
                width: 20px;
            }
            QTreeView::item:hover, QListWidget::item:hover {
                 background-color: QColor(60, 60, 60); /* Slightly lighter on hover */
            }
             QTreeView::item:selected, QListWidget::item:selected {
                 background-color: #2a82da; /* Use highlight color from palette */
                 color: white;
            }
            QTabWidget::pane { /* The tab contents area */
                border-top: 2px solid #C2C7CB;
                position: absolute;
                top: -0.5em; /* Adjust based on font size */
            }
            QTabWidget::tab-bar {
                alignment: left;
            }
            /* Style the tabs */
            QTabBar::tab {
                background: QColor(66, 66, 66); /* Slightly lighter than base */
                border: 1px solid #444;
                border-bottom-color: #C2C7CB; /* Same as pane border color */
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                min-width: 8ex;
                padding: 4px;
                margin-right: 2px; /* Space between tabs */
            }
            QTabBar::tab:selected, QTabBar::tab:hover {
                background: QColor(80, 80, 80);
            }
            QTabBar::tab:selected {
                border-color: #9B9B9B;
                border-bottom-color: #C2C7CB; /* Same as pane border color */
            }
            QTabBar::tab:!selected {
                margin-top: 2px; /* Make non-selected tabs look smaller */
            }
        """)


    # --- Backend Interaction Functions ---

    def run_command(self, command_list, on_finished, on_error, on_progress, use_pkexec=False, progress_id=None):
        if self.current_worker and self.current_worker.isRunning():
            self.show_error("Another operation is already in progress.")
            return

        self.status_bar.showMessage(f"Running: {' '.join(command_list)}...")
        self.progress_bar.setRange(0, 0) # Indeterminate
        self.progress_bar.setVisible(True)
        self.cancel_button.setEnabled(True)
        self.tabs.setCurrentWidget(self.output_tab) # Switch to output tab
        self.output_console.clear() # Clear previous output
        self.output_console.append(f"Executing: {'pkexec ' if use_pkexec else ''}{' '.join(command_list)}\n{'-'*20}\n")

        self.current_worker = CommandWorker(command_list, use_pkexec)
        self.current_worker.signals.finished.connect(lambda: self._command_finished(on_finished))
        self.current_worker.signals.error.connect(lambda error_msg: self._command_error(error_msg, on_error))
        self.current_worker.signals.progress.connect(self._command_progress)
        # self.current_worker.signals.result.connect(on_result_if_needed) # Handle if command returns parsable result via signal

        # Connect progress bar updates if needed (difficult for emerge)
        # self.current_worker.signals.progress_val.connect(self.progress_bar.setValue)

        self.current_worker.start()

    def _command_finished(self, callback):
        self.status_bar.showMessage("Operation completed successfully.", 5000) # Show for 5 seconds
        self.progress_bar.setVisible(False)
        self.cancel_button.setEnabled(False)
        if self.current_worker:
            self.output_console.append(f"\n{'-'*20}\nOperation finished successfully.")
        self.current_worker = None
        if callback:
            callback() # Execute the success callback

    def _command_error(self, error_msg, callback):
        self.status_bar.showMessage(f"Operation failed: {error_msg.splitlines()[0]}", 5000) # Show first line of error briefly
        self.progress_bar.setVisible(False)
        self.cancel_button.setEnabled(False)
        if self.current_worker: # Append error only if worker exists (might be None if cancelled fast)
            self.output_console.append(f"\n{'-'*20}\nERROR:\n{error_msg}")
        self.show_error(f"Operation Failed:\n{error_msg}")
        self.current_worker = None
        if callback:
            callback(error_msg) # Execute the error callback

    def _command_progress(self, progress_text):
        # Append progress text to the output console
        self.output_console.append(progress_text)
        self.output_console.verticalScrollBar().setValue(self.output_console.verticalScrollBar().maximum()) # Auto-scroll
        # Simple status update (optional)
        # self.status_bar.showMessage(f"Processing: {progress_text[:80]}...") # Show truncated progress in status bar

        # --- Attempt to parse emerge progress (Example - Very Fragile!) ---
        # match = re.search(r'\[(\d+)\s+of\s+(\d+)\]', progress_text)
        # if match:
        #     current, total = int(match.group(1)), int(match.group(2))
        #     if self.progress_bar.maximum() == 0: # If indeterminate, set range
        #          self.progress_bar.setRange(0, total)
        #          self.progress_bar.setTextVisible(True)
        #     if total != self.progress_bar.maximum(): # Update total if it changes
        #         self.progress_bar.setRange(0, total)
        #     self.progress_bar.setValue(current)


    def cancel_operation(self):
        if self.current_worker and self.current_worker.isRunning():
            self.status_bar.showMessage("Attempting to cancel operation...")
            self.current_worker.stop()
            # GUI updates (disabling cancel button, hiding progress bar) are handled
            # by the _command_error slot when the cancellation signal is processed.
        else:
             self.status_bar.showMessage("No operation running to cancel.", 3000)


    def get_selected_items(self, list_widget):
        """Helper to get the text of selected items from a QListWidget."""
        items = list_widget.selectedItems()
        return [item.text() for item in items]

    # --- Specific Actions ---

    def run_sync(self):
        # Check for root - pkexec handles this now
        # if os.geteuid() != 0:
        #    self.show_error("Sync requires root privileges. Run the script with sudo or configure pkexec.")
        #    return
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Sync")
        msg_box.setText("This will synchronize the package repositories using 'emerge --sync'. This may take some time and requires root privileges (via pkexec). Continue?")
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            self.run_command(
                ['emerge', '--sync'],
                on_finished=self._sync_finished,
                on_error=None, # Use default error handling
                on_progress=self._command_progress,
                use_pkexec=True
            )

    def _sync_finished(self):
         self.status_bar.showMessage("Sync finished. Checking for updates...", 3000)
         self.refresh_updates() # Refresh updates list after sync


    def refresh_all(self):
        self.status_bar.showMessage("Refreshing all data...", 0) # Persistent message
        # Clear existing views
        self.installed_package_list.clear()
        self.update_package_list.clear()
        # Add more clears if needed (search results, browse view)

        # Use separate functions to refresh data
        self.refresh_installed_packages()
        self.refresh_updates()
        self.refresh_disk_space()
        # Optionally refresh categories/available packages (can be slow)
        self.load_all_available_packages()

        self.status_bar.showMessage("Refresh complete.", 5000)


    def load_all_available_packages(self):
         """Loads categories and all available packages using equery."""
         self.status_bar.showMessage("Loading available packages (equery list)... May take time.")
         self.progress_bar.setVisible(True)
         self.progress_bar.setRange(0, 0) # Indeterminate

         # Using a simple subprocess call here for simplicity,
         # but a worker thread would be better for responsiveness.
         try:
             # equery list '*/*' gives category/package format
             process = subprocess.run(['equery', 'list', '*/*'], capture_output=True, text=True, check=True, timeout=COMMAND_TIMEOUT)
             self.available_packages_by_cat = {}
             lines = process.stdout.strip().splitlines()
             total = len(lines)
             self.progress_bar.setRange(0, total)
             self.category_tree.clear()
             cat_items = {}

             for i, line in enumerate(lines):
                 if '[ Searching ... ]' in line or '[ Completed' in line: # Skip equery status lines
                      continue
                 match = re.match(r'^\s*(\w+[-\w]*)/([\w+-.]+)-([\d.]+.*)', line.strip()) # Basic parse: cat/name-ver
                 if match:
                     category = match.group(1)
                     package_name = match.group(2)
                     full_name = f"{category}/{package_name}"

                     if category not in self.available_packages_by_cat:
                         self.available_packages_by_cat[category] = []
                         # Add category to tree if not present
                         if category not in cat_items:
                             cat_item = QTreeWidgetItem(self.category_tree, [category])
                             cat_items[category] = cat_item

                     if full_name not in self.available_packages_by_cat[category]: # Avoid duplicates if versions differ
                          self.available_packages_by_cat[category].append(full_name)

                 if i % 100 == 0: # Update progress bar periodically
                     self.progress_bar.setValue(i)
                     QApplication.processEvents() # Keep GUI responsive

             # Sort categories and packages alphabetically
             sorted_categories = sorted(self.available_packages_by_cat.keys())
             self.category_tree.clear() # Clear again before populating sorted
             cat_items = {}
             for category in sorted_categories:
                  cat_item = QTreeWidgetItem(self.category_tree, [category])
                  cat_items[category] = cat_item
                  self.available_packages_by_cat[category].sort()

             self.category_tree.sortItems(0, Qt.SortOrder.AscendingOrder)
             self.status_bar.showMessage("Available packages loaded.", 5000)

         except FileNotFoundError:
              self.show_error("Error: 'equery' command not found. Please install app-portage/gentoolkit.")
         except subprocess.CalledProcessError as e:
              self.show_error(f"Failed to list available packages:\n{e}\n{e.stderr}")
         except subprocess.TimeoutExpired:
              self.show_error(f"Timeout loading available packages after {COMMAND_TIMEOUT} seconds.")
         except Exception as e:
              self.show_error(f"Error loading available packages: {e}")
         finally:
              self.progress_bar.setVisible(False)


    def category_selected(self, item, column):
        category = item.text(column)
        self.browse_package_list.clear()
        if category in self.available_packages_by_cat:
            packages = sorted(self.available_packages_by_cat[category])
            self.browse_package_list.addItems(packages)
        elif item.parent() is None and category != "Categories": # Only load if it's a top-level category click
             self.status_bar.showMessage(f"No packages found or loaded for category '{category}'.")


    def refresh_installed_packages(self):
        self.status_bar.showMessage("Loading installed packages...")
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0,0)
        try:
            # Use equery for better parsing than qlist
            process = subprocess.run(['equery', 'list', '--installed', '*/*'], capture_output=True, text=True, check=True, timeout=60)
            self.installed_packages = sorted([line.strip() for line in process.stdout.strip().splitlines() if not line.startswith('[') ]) # Filter out status lines
            self.installed_package_list.clear()
            self.installed_package_list.addItems(self.installed_packages)
            self.status_bar.showMessage(f"{len(self.installed_packages)} installed packages loaded.", 5000)
        except FileNotFoundError:
            self.show_error("Error: 'equery' command not found. Please install app-portage/gentoolkit.")
        except subprocess.CalledProcessError as e:
            self.show_error(f"Failed to list installed packages:\n{e}\n{e.stderr}")
        except subprocess.TimeoutExpired:
            self.show_error("Timeout loading installed packages.")
        except Exception as e:
            self.show_error(f"Error loading installed packages: {e}")
        finally:
            self.progress_bar.setVisible(False)


    def refresh_updates(self):
        self.status_bar.showMessage("Checking for updates (emerge -upv @world)...")
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, 0) # Indeterminate
        self.update_package_list.clear()

        # We run `emerge -upv` to *list* updates, not perform them.
        # No pkexec needed for checking, but might be needed if run as non-root
        # depending on portage permissions. Let's assume standard user can check.
        # If not, add use_pkexec=True.
        try:
            # Use -p (pretend), -v (verbose), -u (update), -N (newuse), -D (deep)
            # We parse the output of this command.
            command = ['emerge', '-upvND', '@world']
            process = subprocess.run(command, capture_output=True, text=True, timeout=COMMAND_TIMEOUT) # Check=False, handle errors manually

            self.update_list = []
            if process.returncode != 0 and "There are no packages to update" not in process.stdout and "Nothing to merge" not in process.stdout:
                 # Check stderr too for permission errors etc.
                 stderr_msg = process.stderr.strip()
                 if "Permission denied" in stderr_msg or "are you root?" in stderr_msg:
                      self.show_error(f"Permission error checking for updates. Try running '{' '.join(command)}' manually or ensure your user has permissions.\nStderr:\n{stderr_msg}")
                 else:
                      self.show_error(f"Error checking for updates (Exit Code {process.returncode}).\nCommand: {' '.join(command)}\nOutput:\n{process.stdout}\nStderr:\n{stderr_msg}")
                 return # Stop processing if command failed unexpectedly

            # Regex to find lines like: [ebuild U ] sys-kernel/gentoo-sources-6.1.12 -> 6.1.16 [6.1.9]
            # Or: [ebuild N ] dev-python/requests-2.28.2
            # Or: [ebuild R ] media-libs/libpng-1.6.39
            # We are mostly interested in U (Update) and N (New dependency for update)
            update_pattern = re.compile(r"\[ebuild\s+(U|N).*\s+([\w-]+/[\w+-.]+)-([\d.]+.*)\s*(?:->\s*([\d.]+.*))?") # Cat/Pkg-Ver -> NewVer?

            lines = process.stdout.splitlines()
            for line in lines:
                 if line.startswith('[ebuild'):
                     match = update_pattern.search(line)
                     if match:
                         pkg_cat_name = match.group(2) # e.g., sys-kernel/gentoo-sources
                         # Construct full package atom for display/action
                         # Sometimes the version isn't present, handle this
                         current_ver_part = match.group(3) if match.group(3) else ""
                         new_ver_part = f" -> {match.group(4)}" if match.group(4) else ""
                         # Display format: category/package (New Version: X.Y.Z)
                         display_text = f"{pkg_cat_name}{new_ver_part} ({'Update' if match.group(1) == 'U' else 'New Dependency'})"
                         # Store the actionable atom (category/package)
                         self.update_list.append(pkg_cat_name)
                         self.update_package_list.addItem(display_text)


            if not self.update_list:
                self.status_bar.showMessage("System is up to date.", 5000)
                self.update_package_list.addItem("No updates available.")
            else:
                 self.status_bar.showMessage(f"{len(self.update_list)} updates available.", 5000)

        except FileNotFoundError:
             self.show_error("Error: 'emerge' command not found. Is Gentoo setup correctly?")
        except subprocess.TimeoutExpired:
             self.show_error("Timeout checking for updates.")
        except Exception as e:
             self.show_error(f"Error parsing update check: {e}")
        finally:
             self.progress_bar.setVisible(False)


    def search_packages(self):
        keyword = self.search_input.text().strip()
        if not keyword:
            self.show_error("Please enter a search keyword.")
            return

        self.status_bar.showMessage(f"Searching for '{keyword}'...")
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, 0)
        self.search_results_list.clear()

        try:
            # Use 'emerge --search' or 'eix' - emerge is standard
            # --searchdesc (-S) searches descriptions too
            command = ['emerge', '--search', '--searchdesc', keyword]
            process = subprocess.run(command, capture_output=True, text=True, timeout=COMMAND_TIMEOUT)

            # Parse emerge --search output
            # Lines often look like: * category/package
            # Description lines follow indented
            # We only want the package atoms
            results = []
            package_pattern = re.compile(r"^\*\s+([\w-]+/[\w+-.]+)\s*") # Start of line, *, space, cat/pkg
            lines = process.stdout.splitlines()
            for line in lines:
                 match = package_pattern.match(line)
                 if match:
                     results.append(match.group(1))

            self.search_results_list.addItems(sorted(list(set(results)))) # Use set to remove duplicates

            if not results:
                self.status_bar.showMessage(f"No packages found matching '{keyword}'.", 5000)
                self.search_results_list.addItem(f"No results for '{keyword}'.")
            else:
                self.status_bar.showMessage(f"{len(results)} potential matches found for '{keyword}'.", 5000)


        except FileNotFoundError:
             self.show_error("Error: 'emerge' command not found.")
        except subprocess.TimeoutExpired:
             self.show_error(f"Search timed out after {COMMAND_TIMEOUT} seconds.")
        except Exception as e:
             self.show_error(f"Error during search: {e}")
        finally:
             self.progress_bar.setVisible(False)


    def _install_packages(self, packages_to_install):
        if not packages_to_install:
            self.show_error("No packages selected to install.")
            return

        package_str = " ".join(packages_to_install)
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Installation")
        msg_box.setText(f"The following packages will be installed:\n\n{package_str}\n\nThis requires root privileges (via pkexec). Continue?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            command = ['emerge', '--ask=n'] + packages_to_install # --ask=n to avoid interactive prompts if pkexec works
            self.run_command(
                command,
                on_finished=self._install_finished,
                on_error=None, # Default handler
                on_progress=self._command_progress,
                use_pkexec=True
            )

    def _install_finished(self):
         self.status_bar.showMessage("Installation finished. Refreshing package lists...", 3000)
         self.refresh_installed_packages()
         self.refresh_updates() # Check if installed packages resolved update needs

    def install_selected_browse(self):
        selected_packages = self.get_selected_items(self.browse_package_list)
        self._install_packages(selected_packages)

    def install_selected_search(self):
        selected_packages = self.get_selected_items(self.search_results_list)
         # Strip potential version numbers if search results included them
        packages_atoms = [re.sub(r'-[\d\._].*', '', pkg) for pkg in selected_packages]
        self._install_packages(packages_atoms)


    def uninstall_selected(self):
        selected_packages = self.get_selected_items(self.installed_package_list)
        if not selected_packages:
            self.show_error("No packages selected to uninstall.")
            return

        # Need to strip version info from the list items
        # Assuming format category/package-version from equery output
        packages_to_uninstall = []
        for item in selected_packages:
             match = re.match(r'([\w-]+/[\w+-.]+)-[\d.]+', item)
             if match:
                  packages_to_uninstall.append(match.group(1))
             else:
                 # Fallback or warning if format is unexpected
                 packages_to_uninstall.append(item) # Use the raw item, might fail

        package_str = " ".join(packages_to_uninstall)
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Uninstallation")
        msg_box.setText(f"The following packages will be uninstalled (depcleaned):\n\n{package_str}\n\nThis uses 'emerge --deselect' followed potentially by 'emerge --depclean'. Requires root privileges (via pkexec). Continue?")
        msg_box.setIcon(QMessageBox.Icon.Warning)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
             # Gentoo way: deselect first, then depclean (safer)
             # Running two commands sequentially via the worker is tricky.
             # Option 1: Chain them via callbacks (complex state mgmt)
             # Option 2: Run a single command/script that does both.
             # Option 3: Just run --unmerge (less safe regarding dependencies).
             # Let's use --unmerge for simplicity here, but add a note.
             self.output_console.append("Note: Using 'emerge --unmerge'. For safer removal, consider 'emerge --deselect <pkg>' then 'emerge --depclean'.")

             command = ['emerge', '--ask=n', '--unmerge'] + packages_to_uninstall
             self.run_command(
                 command,
                 on_finished=self._uninstall_finished,
                 on_error=None, # Default handler
                 on_progress=self._command_progress,
                 use_pkexec=True
             )

    def _uninstall_finished(self):
         self.status_bar.showMessage("Uninstallation finished. Refreshing package lists...", 3000)
         self.refresh_installed_packages()
         self.refresh_updates()


    def update_selected(self):
         selected_items = self.update_package_list.selectedItems()
         if not selected_items:
             self.show_error("No updates selected.")
             return

         # Extract package atoms (cat/pkg) from the display text
         packages_to_update = []
         for item in selected_items:
             text = item.text()
             match = re.match(r'([\w-]+/[\w+-.]+)', text) # Match cat/pkg at the start
             if match:
                 packages_to_update.append(match.group(1))

         if not packages_to_update:
              self.show_error("Could not parse package names from selection.")
              return

         self._perform_update(packages_to_update)


    def update_all(self):
        if not self.update_list:
            self.show_error("No updates available or list not refreshed.")
            return
        # Use the internally stored list of atoms needing update
        self._perform_update(['@world']) # Emerge @world handles all updates

    def _perform_update(self, packages_or_world):
        package_str = " ".join(packages_or_world)
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Update")
        msg_box.setText(f"The following will be updated:\n\n{package_str}\n\nThis uses 'emerge -uND'. Requires root privileges (via pkexec). Continue?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            command = ['emerge', '--ask=n', '-uND'] + packages_or_world
            self.run_command(
                command,
                on_finished=self._update_finished,
                on_error=None, # Default handler
                on_progress=self._command_progress,
                use_pkexec=True
            )

    def _update_finished(self):
         self.status_bar.showMessage("Update finished. Refreshing package lists...", 3000)
         self.refresh_installed_packages()
         self.refresh_updates() # Refresh updates list


    def refresh_disk_space(self):
        try:
            # Get stats for root partition '/'
            stats = os.statvfs('/')
            total_bytes = stats.f_blocks * stats.f_frsize
            available_bytes = stats.f_bavail * stats.f_frsize # Available to non-root user

            # Convert to GB
            total_gb = total_bytes / (1024**3)
            available_gb = available_bytes / (1024**3)
            used_gb = total_gb - available_gb

            # Format string
            disk_info = f"Disk (/): {used_gb:.1f} / {total_gb:.1f} GB Used ({available_gb:.1f} GB Free)"
            self.disk_space_label.setText(disk_info)

        except Exception as e:
            self.disk_space_label.setText("Disk: Error")
            print(f"Error getting disk space: {e}") # Log error


    # --- Utility Functions ---
    def show_error(self, message):
        QMessageBox.critical(self, "Error", message)

    def closeEvent(self, event):
        # Ensure any running worker is stopped before closing
        if self.current_worker and self.current_worker.isRunning():
            reply = QMessageBox.question(self, 'Confirm Exit',
                                           "An operation is in progress. Are you sure you want to exit? The operation will be cancelled.",
                                           QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                           QMessageBox.StandardButton.No)

            if reply == QMessageBox.StandardButton.Yes:
                self.cancel_operation()
                # Give a moment for cancellation signal to process if needed
                # QTimer.singleShot(100, QApplication.instance().quit)
                # event.accept()
                # Need to properly wait or ensure termination before exit
                self.current_worker.wait(2000) # Wait up to 2 seconds for thread to finish after stop
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()


# --- Main Execution ---
if __name__ == "__main__":
    # Check if running as root - recommend against it, pkexec is preferred
    if os.geteuid() == 0:
         print("Warning: Running this GUI directly as root is not recommended.")
         print("Please run as a regular user. Operations requiring privileges will use pkexec.")
         # Optionally exit here, or just show warning
         # sys.exit("Exiting: Please run as a non-root user.")


    app = QApplication(sys.argv)
    main_window = GentooPackageManagerGUI()
    main_window.show()
    sys.exit(app.exec())
