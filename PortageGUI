import sys
import os
import subprocess
import re
import math
import traceback # For better error reporting
from collections import defaultdict # For grouping queue actions
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QListWidget, QPushButton, QLineEdit, QLabel,
    QStatusBar, QProgressBar, QMessageBox, QTextEdit, QSplitter,
    QListWidgetItem, QTreeWidget, QTreeWidgetItem, QHeaderView
)
from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QObject, QTimer, QRunnable, QThreadPool
)
from PyQt6.QtGui import QPalette, QColor, QIcon, QTextCursor # Import QIcon, QTextCursor

# --- External Library for ANSI -> HTML ---
try:
    from ansi2html import Ansi2HTMLConverter
except ImportError:
    print("Warning: 'ansi2html' library not found. Output coloring disabled. Install with: pip install ansi2html")
    Ansi2HTMLConverter = None # type: ignore

# --- Configuration ---
COMMAND_TIMEOUT = 300  # Timeout for subprocess calls in seconds (e.g., 5 minutes)
REFRESH_INTERVAL = 300000 # Refresh disk space every 5 minutes (in milliseconds)
# Set application icon path (replace with your actual icon path or remove if none)
APP_ICON_PATH = "/usr/share/icons/hicolor/48x48/apps/system-software-install.png" # Example path

# --- Constants ---
ACTION_INSTALL = "install"
ACTION_UNINSTALL = "uninstall"
ACTION_UPDATE = "update"

# --- Worker Signals ---
class WorkerSignals(QObject):
    finished = pyqtSignal()              # Signal emitted when the worker is done (regardless of success/error)
    error = pyqtSignal(str, str)         # Signal emitted on error (command_str, error_message)
    result = pyqtSignal(object)          # Signal emitted with the result (e.g., command output)
    progress = pyqtSignal(str)           # Signal for text updates (lines of output)
    progress_val = pyqtSignal(int, int)  # For progress bar (current, total) - difficult with emerge
    status_update = pyqtSignal(str)      # For updating status bar message from worker

# --- Base Worker Class for Commands ---
class CommandWorker(QRunnable): # Use QRunnable for QThreadPool compatibility
    def __init__(self, command_list, use_pkexec=False, collect_output=False):
        super().__init__()
        self.command_list = command_list
        self.signals = WorkerSignals()
        self.use_pkexec = use_pkexec
        self.collect_output = collect_output
        self.process = None
        self.is_cancelled = False

    def run(self):
        command_str = ' '.join(self.command_list)
        full_command = self.command_list
        collected_stdout = []

        try:
            if self.use_pkexec:
                if subprocess.run(['which', 'pkexec'], capture_output=True, text=True).returncode != 0:
                    self.signals.error.emit(command_str, "Error: 'pkexec' command not found. Is PolicyKit installed?")
                    self.signals.finished.emit()
                    return
                full_command = ['pkexec', '--disable-internal-agent'] + self.command_list
                command_str = 'pkexec ' + command_str # Update for error reporting

            self.process = subprocess.Popen(
                full_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1, # Line buffered
                errors='replace', # Handle potential decoding errors
                preexec_fn=os.setsid # Create process group for easier killing
            )

            # Stream stdout for progress
            if self.process.stdout:
                for line in iter(self.process.stdout.readline, ''):
                    if self.is_cancelled:
                        break
                    line_strip = line.strip()
                    self.signals.progress.emit(line_strip) # Emit raw line for console
                    if self.collect_output:
                        collected_stdout.append(line_strip) # Store if needed
                self.process.stdout.close()

            if self.is_cancelled:
                    self.signals.error.emit(command_str, "Operation Cancelled")
                    self.signals.finished.emit()
                    return # Don't proceed further if cancelled

            # Wait for the process to finish and get stderr
            stderr_output = ""
            if self.process.stderr:
                stderr_output = self.process.stderr.read()
                self.process.stderr.close()

            # Use poll() first, then wait() with timeout only if necessary
            return_code = self.process.poll()
            if return_code is None:
                try:
                    self.process.wait(timeout=COMMAND_TIMEOUT)
                    return_code = self.process.returncode
                except subprocess.TimeoutExpired:
                    self.process.kill() # Ensure it's stopped before trying killpg
                    try:
                        pgid = os.getpgid(self.process.pid)
                        os.killpg(pgid, 9) # SIGKILL group
                    except ProcessLookupError:
                         pass # Process might have died already
                    except Exception as ke:
                         print(f"Warning: Error during group kill after timeout: {ke}")
                    self.signals.error.emit(command_str, f"Command timed out after {COMMAND_TIMEOUT} seconds.")
                    self.signals.finished.emit()
                    return
            # else: return_code is already set

            if return_code != 0:
                error_message = f"Command failed with exit code {return_code}.\n"
                error_message += f"Command: {' '.join(full_command)}\n"
                if stderr_output:
                    error_message += f"Stderr:\n{stderr_output.strip()}"
                else:
                    # Check stdout if stderr is empty
                    stdout_for_error = "\n".join(collected_stdout[-10:]) # Last 10 lines might help
                    if stdout_for_error:
                        error_message += f"\nLast Output Lines:\n{stdout_for_error}"
                    else:
                        error_message += "Check console output for details (no specific stderr)."

                # Try to extract common emerge errors
                if "emerge --sync" in command_str:
                    if "are you root?" in stderr_output.lower() or "permission denied" in stderr_output.lower():
                        error_message += "\n\nHint: Sync requires root privileges. Check pkexec configuration or run command manually."
                self.signals.error.emit(command_str, error_message)
            else:
                # Send collected output if requested, otherwise just signal success
                if self.collect_output:
                    self.signals.result.emit("\n".join(collected_stdout))
                else:
                    self.signals.result.emit("Command finished successfully.") # Send generic success

        except FileNotFoundError:
            self.signals.error.emit(command_str, f"Error: Command '{self.command_list[0]}' not found. Is it installed and in PATH?")
        except subprocess.TimeoutExpired: # Should be caught above, but as fallback
            if self.process: self.process.kill()
            self.signals.error.emit(command_str, f"Command timed out unexpectedly.\nCommand: {' '.join(full_command)}")
        except Exception as e:
            self.signals.error.emit(command_str, f"An unexpected error occurred in worker: {e}\nCommand: {' '.join(full_command)}\n{traceback.format_exc()}")
        finally:
            self.signals.finished.emit() # Always emit finished

    def stop(self):
        self.is_cancelled = True
        if self.process and self.process.poll() is None: # Check if process is running
            self.signals.status_update.emit("Attempting process termination...")
            try:
                # Use killpg with SIGTERM first, then SIGKILL
                pgid = os.getpgid(self.process.pid)
                os.killpg(pgid, 15) # Send SIGTERM to process group
                try:
                    self.process.wait(timeout=2) # Wait a bit
                    self.signals.status_update.emit("Process terminated.")
                except subprocess.TimeoutExpired:
                    self.signals.status_update.emit("Forcing process termination (SIGKILL)...")
                    os.killpg(pgid, 9) # Send SIGKILL to process group
            except ProcessLookupError:
                 self.signals.status_update.emit("Process already finished.")
            except Exception as e:
                # Fallback if killpg fails
                self.signals.status_update.emit(f"Could not stop process group ({e}), trying direct kill...")
                try:
                    self.process.kill()
                except Exception as ke:
                    self.signals.status_update.emit(f"Could not stop process: {ke}")


# --- Main Application Window ---
class GentooPackageManagerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gentoo GUI Package Manager")
        self.setGeometry(100, 100, 1000, 700)

        # Set App Icon
        if os.path.exists(APP_ICON_PATH):
            self.setWindowIcon(QIcon(APP_ICON_PATH))

        # --- Thread Pool ---
        self.threadpool = QThreadPool()
        # self.threadpool.setMaxThreadCount(2) # Limit concurrent threads if needed
        self.active_workers = 0 # Count active workers
        self.current_action_worker = None # Reference to the worker handling queue apply/sync

        # --- Data storage ---
        self.installed_packages = [] # List of full "cat/pkg-ver" strings
        self.installed_packages_map = {} # Map "cat/pkg" -> "cat/pkg-ver" for easy lookup
        self.available_packages_by_cat = {} # category -> list of "cat/pkg" atoms
        self.update_list = [] # Stores actionable "cat/pkg" atoms for updates
        self.pending_actions = {} # Stores packages queued for actions: "cat/pkg": ACTION_TYPE

        # --- ANSI Converter ---
        self.ansi_converter = Ansi2HTMLConverter(inline=True, dark_bg=True) if Ansi2HTMLConverter else None

        # --- Setup UI ---
        self.setup_ui()
        self.apply_dark_mode()

        # --- Initial Load (using threads) ---
        self.refresh_installed_packages()
        self.refresh_disk_space() # Initial disk space check (fast, no thread needed)
        self.refresh_updates()     # Check for updates on startup
        self.load_all_available_packages()

        # --- Setup Timer for Disk Space Refresh ---
        self.disk_space_timer = QTimer(self)
        self.disk_space_timer.timeout.connect(self.refresh_disk_space)
        self.disk_space_timer.start(REFRESH_INTERVAL)

    def setup_ui(self):
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)

        # --- Tabs ---
        self.tabs = QTabWidget()
        self.layout.addWidget(self.tabs)

        # Create Tabs
        self.browse_tab = QWidget()
        self.installed_tab = QWidget()
        self.queue_tab = QWidget() # Renamed from search_tab
        self.update_tab = QWidget()
        self.output_tab = QWidget() # Tab to show command output

        self.tabs.addTab(self.browse_tab, "Browse Packages")
        self.tabs.addTab(self.installed_tab, "Installed Packages")
        self.tabs.addTab(self.queue_tab, "Queue") # Renamed
        self.tabs.addTab(self.update_tab, "Updates")
        self.tabs.addTab(self.output_tab, "Output Console")

        # --- Setup Tab Layouts ---
        self._setup_browse_tab()
        self._setup_installed_tab()
        self._setup_queue_tab() # Renamed
        self._setup_update_tab()
        self._setup_output_tab()

        # --- Bottom Bar (Refresh Button, Status Bar, Progress) ---
        self.bottom_bar_layout = QHBoxLayout()
        self.layout.addLayout(self.bottom_bar_layout)

        self.refresh_button = QPushButton("Refresh Lists")
        self.refresh_button.setToolTip("Reload Installed, Updates, and Available Packages lists.")
        self.refresh_button.clicked.connect(self.refresh_all)
        self.bottom_bar_layout.addWidget(self.refresh_button)

        self.sync_button = QPushButton("Sync Repositories")
        self.sync_button.setToolTip("Run 'emerge --sync' (requires root privileges via pkexec).")
        self.sync_button.clicked.connect(self.run_sync)
        self.bottom_bar_layout.addWidget(self.sync_button)

        self.cancel_button = QPushButton("Cancel Action")
        self.cancel_button.setToolTip("Attempt to cancel the current Apply Queue or Sync operation.")
        self.cancel_button.clicked.connect(self.cancel_action_worker)
        self.cancel_button.setEnabled(False) # Disabled initially
        self.bottom_bar_layout.addWidget(self.cancel_button)

        self.bottom_bar_layout.addStretch(1) # Push status stuff to the right

        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setRange(0, 0) # Indeterminate initially
        self.progress_bar.setVisible(False) # Hide initially
        self.status_bar.addPermanentWidget(self.progress_bar, 1) # Takes stretch space

        self.disk_space_label = QLabel("Disk: ?/? GB")
        self.status_bar.addPermanentWidget(self.disk_space_label)

    def _setup_browse_tab(self):
        layout = QVBoxLayout(self.browse_tab) # Use QVBoxLayout for filter

        # Filter Input
        self.browse_filter_input = QLineEdit()
        self.browse_filter_input.setPlaceholderText("Filter packages in selected category...")
        self.browse_filter_input.textChanged.connect(self._filter_browse_list)
        layout.addWidget(self.browse_filter_input)

        splitter = QSplitter(Qt.Orientation.Horizontal)
        layout.addWidget(splitter) # Add splitter to the main layout

        # Left side: Categories Tree
        cat_widget = QWidget()
        cat_layout = QVBoxLayout(cat_widget)
        cat_layout.setContentsMargins(0,0,0,0)
        self.category_tree = QTreeWidget()
        self.category_tree.setHeaderLabel("Categories")
        self.category_tree.itemSelectionChanged.connect(self.category_selected) # Use selectionChanged for better response
        cat_layout.addWidget(self.category_tree)
        splitter.addWidget(cat_widget)

        # Right side: Packages List and Action Button
        right_pane_widget = QWidget()
        right_layout = QVBoxLayout(right_pane_widget)
        right_layout.setContentsMargins(0,0,0,0)
        splitter.addWidget(right_pane_widget)

        self.browse_package_list = QListWidget()
        self.browse_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        right_layout.addWidget(self.browse_package_list)

        browse_button_layout = QHBoxLayout()
        self.browse_add_queue_button = QPushButton("Add Selected to Install Queue")
        self.browse_add_queue_button.clicked.connect(self.add_browse_to_queue)
        browse_button_layout.addWidget(self.browse_add_queue_button)
        right_layout.addLayout(browse_button_layout)

        splitter.setSizes([300, 700]) # Adjust initial sizes

    def _setup_installed_tab(self):
        layout = QVBoxLayout(self.installed_tab)

        # Filter Input
        self.installed_filter_input = QLineEdit()
        self.installed_filter_input.setPlaceholderText("Filter installed packages (name or version)...")
        self.installed_filter_input.textChanged.connect(self._filter_installed_list)
        layout.addWidget(self.installed_filter_input)

        # Package List
        self.installed_package_list = QListWidget()
        self.installed_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.installed_package_list)

        # Action Button
        button_layout = QHBoxLayout()
        self.add_uninstall_queue_button = QPushButton("Add Selected to Uninstall Queue")
        self.add_uninstall_queue_button.clicked.connect(self.add_installed_to_queue)
        button_layout.addWidget(self.add_uninstall_queue_button)
        layout.addLayout(button_layout)

    def _setup_queue_tab(self): # Renamed from _setup_search_tab
        layout = QVBoxLayout(self.queue_tab)

        queue_label = QLabel("Pending Actions (Check items to include):")
        layout.addWidget(queue_label)

        self.queue_list = QListWidget()
        # Items will be added with checkboxes later
        layout.addWidget(self.queue_list)

        button_layout = QHBoxLayout()
        self.apply_queue_button = QPushButton("Apply Queued Changes")
        self.apply_queue_button.clicked.connect(self.apply_queue)
        button_layout.addWidget(self.apply_queue_button)

        self.clear_queue_button = QPushButton("Clear Queue")
        self.clear_queue_button.clicked.connect(self.clear_queue)
        button_layout.addWidget(self.clear_queue_button)
        layout.addLayout(button_layout)

    def _setup_update_tab(self):
        layout = QVBoxLayout(self.update_tab)
        self.update_package_list = QListWidget()
        self.update_package_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection) # Allow multi-select
        layout.addWidget(self.update_package_list)

        button_layout = QHBoxLayout()
        self.update_selected_queue_button = QPushButton("Add Selected to Update Queue")
        self.update_selected_queue_button.clicked.connect(self.add_updates_to_queue)
        button_layout.addWidget(self.update_selected_queue_button)

        self.update_all_queue_button = QPushButton("Add All (@world) to Update Queue")
        self.update_all_queue_button.clicked.connect(self.add_update_all_to_queue)
        button_layout.addWidget(self.update_all_queue_button)

        layout.addLayout(button_layout)

    def _setup_output_tab(self):
        layout = QVBoxLayout(self.output_tab)
        self.output_console = QTextEdit()
        self.output_console.setReadOnly(True)
        self.output_console.setAcceptRichText(True) # Ensure rich text is accepted for HTML
        self.output_console.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap) # Prevent wrapping for better readability
        layout.addWidget(self.output_console)

    def apply_dark_mode(self):
        dark_palette = QPalette()
        # Base Colors
        dark_palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.WindowText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Base, QColor(42, 42, 42))
        dark_palette.setColor(QPalette.ColorRole.AlternateBase, QColor(66, 66, 66))
        dark_palette.setColor(QPalette.ColorRole.ToolTipBase, Qt.GlobalColor.black)
        dark_palette.setColor(QPalette.ColorRole.ToolTipText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ColorRole.ButtonText, Qt.GlobalColor.white)
        dark_palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
        # Highlight Colors
        dark_palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.white)
        # Disabled Colors
        dark_palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(127, 127, 127))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Highlight, QColor(80, 80, 80))
        dark_palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.HighlightedText, QColor(127, 127, 127))

        app = QApplication.instance()
        if app:
             app.setPalette(dark_palette)

             # Apply stylesheet
             app.setStyleSheet("""
                 QToolTip {
                     color: #ffffff; background-color: #2a82da; border: 1px solid white; padding: 2px;
                 }
                 QProgressBar {
                     border: 1px solid grey; border-radius: 5px; text-align: center;
                     background-color: #2A2A2A; /* Dark background for progress bar */
                     color: white; /* Text color for indeterminate */
                 }
                 QProgressBar::chunk {
                     background-color: #4287f5; /* Blue progress chunk */
                     width: 10px; margin: 0.5px; /* Optional margin */
                 }
                 QTreeView::item:hover, QListWidget::item:hover {
                      background-color: QColor(60, 60, 60);
                 }
                  QTreeView::item:selected, QListWidget::item:selected {
                      background-color: #2a82da; color: white;
                  }
                  /* Style for items with checkboxes in the Queue */
                  QListWidget::item { padding: 3px; } /* Add some padding */

                 QTabWidget::pane { /* The tab contents area */
                      border-top: 2px solid #C2C7CB; position: absolute; top: -0.5em;
                  }
                  QTabWidget::tab-bar { alignment: left; }
                  QTabBar::tab {
                      background: QColor(66, 66, 66); border: 1px solid #444;
                      border-bottom-color: #C2C7CB; border-top-left-radius: 4px;
                      border-top-right-radius: 4px; min-width: 8ex; padding: 4px; margin-right: 2px; color: white;
                  }
                  QTabBar::tab:selected, QTabBar::tab:hover { background: QColor(80, 80, 80); }
                  QTabBar::tab:selected { border-color: #9B9B9B; border-bottom-color: #C2C7CB; font-weight: bold;}
                  QTabBar::tab:!selected { margin-top: 2px; }
                  QTextEdit { /* Ensure console matches theme */
                      background-color: #2A2A2A; color: #E0E0E0; /* Slightly off-white text */
                      font-family: Monospace; /* Monospace font */
                 }
                 QLineEdit { padding: 2px; }
             """)


    # --- Threading and Command Execution ---

    def start_worker(self, worker, is_action_worker=False):
        """Starts a worker, tracks counts, and updates UI."""
        if is_action_worker:
            if self.current_action_worker:
                self.show_error("Another Apply Queue or Sync operation is already in progress.")
                return False # Indicate failure to start
            self.current_action_worker = worker

        self.threadpool.start(worker)
        self.active_workers += 1
        self._update_ui_for_busy_state()
        return True # Indicate successful start

    def _worker_finished(self):
        """Decrements worker count and updates UI when ANY worker finishes."""
        self.active_workers = max(0, self.active_workers - 1) # Ensure it doesn't go negative
        # Note: We don't check self.current_action_worker here,
        # that's handled in _action_worker_finished or _command_error
        self._update_ui_for_busy_state()

    def _action_worker_finished(self, operation_name, callback):
        """Handles cleanup specific to the main action worker (Apply Queue/Sync) on SUCCESS."""
        if self.current_action_worker and not self.current_action_worker.is_cancelled:
            self.status_bar.showMessage(f"{operation_name} completed successfully.", 5000)
            self.output_console.append(f"\n{'-'*20}\n{operation_name} finished successfully.")
            if callback:
                try:
                    callback() # Execute the success callback
                except Exception as e:
                    self.show_error(f"Error in {operation_name} finished callback: {e}\n{traceback.format_exc()}")
        # Else (if cancelled or error), status message is handled by _command_error

        # Clear the reference ONLY if it's the one we tracked
        # This worker is now done (success, error, or cancelled)
        self.current_action_worker = None
        self._update_ui_for_busy_state() # Update button states

    def _command_error(self, command_str, error_msg, error_callback=None, is_action_worker=False):
        """Handles errors from ANY worker."""
        # Only show pop-up if it wasn't a user cancellation
        if "Operation Cancelled" not in error_msg:
             self.show_error(f"Operation Failed:\n{error_msg}")
             self.status_bar.showMessage(f"Error: {error_msg.splitlines()[0]}", 8000)
             self.output_console.append(f"\n{'-'*20}\nERROR:\nCommand: {command_str}\n{error_msg}")
        else:
             self.status_bar.showMessage("Operation Cancelled", 5000)
             self.output_console.append(f"\n{'-'*20}\nOperation Cancelled by User.")

        # If this error came from the action worker, clear the reference.
        if is_action_worker:
            self.current_action_worker = None

        if error_callback:
            try:
                error_callback(error_msg) # Execute the specific error callback
            except Exception as e:
                self.show_error(f"Error in error callback: {e}\n{traceback.format_exc()}")

        # _worker_finished signal will still fire afterwards to decrement counter
        # and _update_ui_for_busy_state will run again.


    def _command_progress(self, progress_text):
        """Handles progress text updates, converting ANSI to HTML."""
        if self.ansi_converter:
            html_line = self.ansi_converter.convert(progress_text, full=False)
            self.output_console.moveCursor(QTextCursor.MoveOperation.End)
            self.output_console.insertHtml(html_line + "<br>") # Append as HTML
        else:
            self.output_console.append(progress_text) # Fallback

        # Auto-scroll to the bottom
        self.output_console.verticalScrollBar().setValue(self.output_console.verticalScrollBar().maximum())

    def _update_ui_for_busy_state(self):
        """Enable/disable buttons based on worker states."""
        is_general_busy = self.active_workers > 0
        is_action_busy = self.current_action_worker is not None

        # Refresh is disabled if *any* worker is active
        self.refresh_button.setEnabled(not is_general_busy)

        # Sync and Apply Queue are disabled if an *action* worker is active
        self.sync_button.setEnabled(not is_action_busy)
        self.apply_queue_button.setEnabled(not is_action_busy and bool(self.pending_actions)) # Also check if queue not empty
        self.clear_queue_button.setEnabled(not is_action_busy) # Can clear queue even if list refresh is running

        # Cancel button enabled only if an action worker is running
        self.cancel_button.setEnabled(is_action_busy)

        # Queue manipulation buttons disabled if action worker is busy
        can_modify_queue = not is_action_busy
        self.browse_add_queue_button.setEnabled(can_modify_queue)
        self.add_uninstall_queue_button.setEnabled(can_modify_queue)
        self.update_selected_queue_button.setEnabled(can_modify_queue)
        self.update_all_queue_button.setEnabled(can_modify_queue)

        # Progress bar visibility
        if is_general_busy and not self.progress_bar.isVisible():
            self.progress_bar.setRange(0,0) # Indeterminate
            self.progress_bar.setVisible(True)
        elif not is_general_busy and self.progress_bar.isVisible():
            self.progress_bar.setVisible(False)


    def run_action_command(self, command_list, on_success_callback=None, on_error_callback=None, use_pkexec=False, operation_name="Operation"):
        """
        Runs a command that requires privileged access and manages the
        `current_action_worker` for cancellation (Sync, Apply Queue).
        Returns True if started, False if another action was already running.
        """
        command_str = ' '.join(command_list)
        self.status_bar.showMessage(f"Starting: {operation_name}...")
        self.progress_bar.setRange(0, 0) # Indeterminate
        self.progress_bar.setVisible(True)
        self.tabs.setCurrentWidget(self.output_tab) # Switch to output tab
        self.output_console.clear() # Clear previous output
        self.output_console.append(f"Executing ({operation_name}): {'pkexec ' if use_pkexec else ''}{command_str}\n{'-'*20}\n")

        worker = CommandWorker(command_list, use_pkexec, collect_output=False) # No collected output needed usually

        # Connect signals - pass is_action_worker=True to error/finished handlers
        worker.signals.result.connect(lambda res: None) # Generic success message handled by _action_worker_finished
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err, on_error_callback, is_action_worker=True))
        worker.signals.progress.connect(self._command_progress)
        worker.signals.status_update.connect(self.status_bar.showMessage)
        worker.signals.finished.connect(self._worker_finished) # Generic decrement counter
        worker.signals.finished.connect(lambda: self._action_worker_finished(operation_name, on_success_callback)) # Action-specific cleanup/callback

        # Try to start the worker
        if not self.start_worker(worker, is_action_worker=True):
            # Failed to start (likely another action running)
            self.progress_bar.setVisible(self.active_workers > 0) # Re-evaluate progress bar
            return False # Indicate failure
        return True # Indicate success

    def cancel_action_worker(self):
        """Attempts to cancel the currently running action worker (Apply Queue/Sync)."""
        if self.current_action_worker:
            self.status_bar.showMessage("Attempting to cancel operation...")
            self.cancel_button.setEnabled(False) # Disable immediately
            self.current_action_worker.stop()
            # Further UI updates (status message, button re-enabling) are handled by
            # the worker's finished/error signals (_action_worker_finished, _command_error).
        else:
            self.status_bar.showMessage("No cancellable operation running.", 3000)


    def get_selected_items_text(self, list_widget):
        """Helper to get the text of selected items from a QListWidget."""
        items = list_widget.selectedItems()
        return [item.text() for item in items]

    # --- Filtering ---
    def _filter_list_widget(self, filter_text, list_widget, source_data):
        """Generic function to filter items in a QListWidget."""
        filter_lower = filter_text.lower()
        list_widget.setUpdatesEnabled(False) # Pause updates for performance
        try:
            # Iterate by index is safer when modifying visibility
            for i in range(list_widget.count()):
                item = list_widget.item(i)
                if item:
                    item_text = item.text().lower()
                    # Very simple substring matching
                    item.setHidden(filter_lower not in item_text)
        finally:
             list_widget.setUpdatesEnabled(True) # Re-enable updates

    def _filter_browse_list(self, text):
        """Filters the browse package list based on category selection."""
        selected_category_items = self.category_tree.selectedItems()
        if not selected_category_items:
            # If no category selected, maybe filter *all* visible items?
            # For now, let's just apply filter to the currently displayed list items
            # Get current items (might be slow for huge lists)
            # current_items_text = [self.browse_package_list.item(i).text() for i in range(self.browse_package_list.count())]
            # self._filter_list_widget(text, self.browse_package_list, current_items_text) # Requires source_data to match displayed items
            # Simpler: iterate through existing items
             filter_lower = text.lower()
             for i in range(self.browse_package_list.count()):
                 item = self.browse_package_list.item(i)
                 if item:
                     item.setHidden(filter_lower not in item.text().lower())

        else:
             category = selected_category_items[0].text(0)
             if category in self.available_packages_by_cat:
                 # The list *should* only contain items from this category
                 # We just need to hide/show them based on the filter text
                 filter_lower = text.lower()
                 for i in range(self.browse_package_list.count()):
                     item = self.browse_package_list.item(i)
                     if item:
                         # Item text is "cat/pkg"
                         item.setHidden(filter_lower not in item.text().lower())

    def _filter_installed_list(self, text):
        """Filters the installed package list."""
        # Source data is self.installed_packages (which contains "cat/pkg-ver")
        self._filter_list_widget(text, self.installed_package_list, self.installed_packages)


    # --- Queue Management ---

    def _add_to_queue(self, package_atom, action_type):
        """Adds or updates a package action in the queue."""
        if not package_atom: return False

        # Simple conflict resolution: last action wins
        self.pending_actions[package_atom] = action_type
        print(f"Queued: {package_atom} for {action_type}") # Debugging
        self._update_queue_display()
        return True

    def _remove_from_queue(self, package_atom):
        """Removes a package from the queue."""
        if package_atom in self.pending_actions:
            del self.pending_actions[package_atom]
            print(f"Removed from queue: {package_atom}") # Debugging
            self._update_queue_display()
            return True
        return False

    def _update_queue_display(self):
        """Updates the QListWidget in the Queue tab."""
        self.queue_list.clear()
        if not self.pending_actions:
            self.queue_list.addItem("Queue is empty.")
            self.apply_queue_button.setEnabled(False)
            return

        self.apply_queue_button.setEnabled(not self.current_action_worker) # Enable if not busy

        # Sort items for display (by package name)
        sorted_atoms = sorted(self.pending_actions.keys())

        action_map = {
            ACTION_INSTALL: "Install",
            ACTION_UNINSTALL: "Uninstall",
            ACTION_UPDATE: "Update"
        }

        for atom in sorted_atoms:
            action = self.pending_actions[atom]
            action_text = action_map.get(action, "Unknown Action")
            display_text = f"[{action_text}] {atom}"

            item = QListWidgetItem(display_text)
            item.setData(Qt.ItemDataRole.UserRole, (atom, action)) # Store atom and action
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(Qt.CheckState.Checked) # Default to checked
            self.queue_list.addItem(item)

    def add_browse_to_queue(self):
        """Adds selected packages from Browse tab to install queue."""
        selected_items = self.get_selected_items_text(self.browse_package_list)
        added_count = 0
        for item_text in selected_items:
            # Item text should be "cat/pkg"
            atom_match = re.match(r'^([\w-]+(?:/[\w-]+)*/[\w.+-]+)$', item_text)
            if atom_match:
                atom = atom_match.group(1)
                if self._add_to_queue(atom, ACTION_INSTALL):
                     added_count += 1
        if added_count > 0:
             self.status_bar.showMessage(f"Added {added_count} package(s) to install queue.", 3000)
             self.tabs.setCurrentWidget(self.queue_tab) # Switch to queue tab
        elif selected_items:
             self.show_error("Could not parse selected package names.")
        else:
             self.show_error("No packages selected.")


    def add_installed_to_queue(self):
        """Adds selected packages from Installed tab to uninstall queue."""
        selected_items = self.get_selected_items_text(self.installed_package_list)
        added_count = 0
        # Pattern to extract cat/pkg from cat/pkg-ver
        pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*/[\w.+-]+)-[\d].*')
        for item_text in selected_items:
            match = pattern.match(item_text)
            if match:
                atom = match.group(1)
                if self._add_to_queue(atom, ACTION_UNINSTALL):
                    added_count += 1
            else:
                print(f"Warning: Could not parse atom from installed package: {item_text}")

        if added_count > 0:
            self.status_bar.showMessage(f"Added {added_count} package(s) to uninstall queue.", 3000)
            self.tabs.setCurrentWidget(self.queue_tab)
        elif selected_items:
            self.show_error("Could not parse selected package names for uninstallation.")
        else:
            self.show_error("No packages selected.")

    def add_updates_to_queue(self):
        """Adds selected packages from Updates tab to update queue."""
        selected_items = self.update_package_list.selectedItems() # Get items, not just text
        added_count = 0
        # Extract package atom stored in item data
        for item in selected_items:
             atom = item.data(Qt.ItemDataRole.UserRole) # Atom was stored here
             if atom:
                 if self._add_to_queue(atom, ACTION_UPDATE):
                     added_count += 1

        if added_count > 0:
            self.status_bar.showMessage(f"Added {added_count} package(s) to update queue.", 3000)
            self.tabs.setCurrentWidget(self.queue_tab)
        elif len(selected_items)>0: # Check original selection length
            self.show_error("Could not get package names from selection.")
        else:
            self.show_error("No updates selected.")


    def add_update_all_to_queue(self):
        """Adds all available updates (@world) to the update queue."""
        if not self.update_list:
            self.show_error("No updates found or list not refreshed.")
            return

        added_count = 0
        for atom in self.update_list:
            if self._add_to_queue(atom, ACTION_UPDATE):
                 added_count += 1

        if added_count > 0:
             # Optional: Add a special marker for @world? Or just add individual items.
             # Let's stick to individual items for consistency.
             self.status_bar.showMessage(f"Added all {added_count} available updates to queue.", 3000)
             self.tabs.setCurrentWidget(self.queue_tab)
        else:
            self.show_error("Failed to add updates to queue.")


    def clear_queue(self):
        """Clears all pending actions."""
        if self.pending_actions:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Confirm Clear Queue")
            msg_box.setText("Are you sure you want to remove all pending actions from the queue?")
            msg_box.setIcon(QMessageBox.Icon.Question)
            msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            msg_box.setDefaultButton(QMessageBox.StandardButton.No)
            if msg_box.exec() == QMessageBox.StandardButton.Yes:
                self.pending_actions.clear()
                self._update_queue_display()
                self.status_bar.showMessage("Queue cleared.", 3000)
        else:
            self.status_bar.showMessage("Queue is already empty.", 3000)

    def apply_queue(self):
        """Applies the checked actions in the queue."""
        actions_to_apply = defaultdict(list) # Group by action type
        atoms_applied = []

        for i in range(self.queue_list.count()):
            item = self.queue_list.item(i)
            if item and item.checkState() == Qt.CheckState.Checked:
                data = item.data(Qt.ItemDataRole.UserRole)
                if data:
                    atom, action_type = data
                    actions_to_apply[action_type].append(atom)
                    atoms_applied.append(atom)

        if not actions_to_apply:
            self.show_error("No actions checked in the queue to apply.")
            return

        summary = []
        if actions_to_apply[ACTION_INSTALL]:
             summary.append(f"Install: {len(actions_to_apply[ACTION_INSTALL])} packages")
        if actions_to_apply[ACTION_UPDATE]:
             summary.append(f"Update: {len(actions_to_apply[ACTION_UPDATE])} packages")
        if actions_to_apply[ACTION_UNINSTALL]:
             summary.append(f"Uninstall: {len(actions_to_apply[ACTION_UNINSTALL])} packages")

        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Apply Changes")
        msg_box.setText("The following actions will be performed:\n\n" + "\n".join(summary) + "\n\nThis requires root privileges (via pkexec). Continue?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            # --- Execute commands ---
            # We should run install/update together, then uninstall separately.
            install_update_list = actions_to_apply[ACTION_INSTALL] + actions_to_apply[ACTION_UPDATE]
            uninstall_list = actions_to_apply[ACTION_UNINSTALL]

            commands = []
            if install_update_list:
                 # Use -uND for updates, plain emerge for installs. Combine them.
                 # emerge --ask=n --verbose <install_pkg1> <update_pkg1> ...
                 # Or more robustly: emerge --ask=n --verbose -uND <all_involved_pkgs>
                 # Let's use the simpler combined list first. emerge should handle it.
                 # Using -uND should be safe even for packages only being installed.
                 cmd = ['emerge', '--ask=n', '--verbose', '-uND'] + install_update_list
                 commands.append({'cmd': cmd, 'op': 'Install/Update'})

            if uninstall_list:
                 cmd = ['emerge', '--ask=n', '--verbose', '--unmerge'] + uninstall_list
                 commands.append({'cmd': cmd, 'op': 'Uninstall'})

            # Store applied atoms to remove them from queue on success
            self._original_atoms_for_cleanup = list(atoms_applied) # Make a copy
            self._commands_to_run = list(commands) # Make a copy

            # Start the first command
            self._run_next_queued_command()


    def _run_next_queued_command(self):
         """Runs the next command in the sequence from the apply queue."""
         if not self._commands_to_run:
             # All commands completed successfully
             self._queue_apply_finished()
             return

         command_info = self._commands_to_run.pop(0) # Get and remove first command
         cmd = command_info['cmd']
         op_name = command_info['op']

         # Run this command using run_action_command
         # On success, it calls _run_next_queued_command again
         # On error, it calls _queue_apply_failed
         success = self.run_action_command(
             cmd,
             on_success_callback=self._run_next_queued_command, # Recurse on success
             on_error_callback=self._queue_apply_failed,     # Handle failure
             use_pkexec=True,
             operation_name=f"Apply Queue ({op_name})"
         )
         if not success:
              # Could not start (e.g., another action running - should not happen here normally)
              self.show_error(f"Failed to start command for {op_name}.")
              # Put the command back? Maybe just fail the whole sequence.
              self._commands_to_run.insert(0, command_info) # Put it back
              self._queue_apply_failed("Failed to start worker.")


    def _queue_apply_finished(self):
        """Called only when ALL commands in the queue sequence finish successfully."""
        self.status_bar.showMessage("All queued actions applied successfully. Refreshing lists...", 5000)
        # Clean up applied items from the main pending_actions dict
        for atom in self._original_atoms_for_cleanup:
            if atom in self.pending_actions:
                del self.pending_actions[atom]
        self._update_queue_display()

        # Refresh relevant lists
        self.refresh_installed_packages()
        self.refresh_updates()
        # No need to clear self._commands_to_run or self._original_atoms_for_cleanup here
        # as they are managed during the process.

    def _queue_apply_failed(self, error_msg):
        """Called if any command in the queue sequence fails."""
        self.show_error(f"Queue application failed: {error_msg}")
        self.status_bar.showMessage("Queue application failed. See Output Console.", 6000)
        # Do not remove items from the queue automatically on failure.
        # Clear the remaining commands to run
        self._commands_to_run = []
        self._original_atoms_for_cleanup = []


    # --- Specific Actions (Sync, Refresh) ---

    def run_sync(self):
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Confirm Sync")
        msg_box.setText("This will synchronize the package repositories using 'emerge --sync'. This may take some time and requires root privileges (via pkexec). Continue?")
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            self.run_action_command( # Use the action command runner
                ['emerge', '--sync'],
                on_success_callback=self._sync_finished, # Specific callback on success
                use_pkexec=True,
                operation_name="Repository Sync"
            )

    def _sync_finished(self):
        """Called only on successful completion of sync."""
        self.status_bar.showMessage("Sync finished successfully. Refreshing updates list...", 4000)
        self.refresh_updates() # Refresh updates list after successful sync

    def refresh_all(self):
        """Refreshes all data lists using background threads."""
        if self.active_workers > 0:
            self.show_error("Cannot refresh while other operations are in progress.")
            return

        self.status_bar.showMessage("Refreshing all data lists...")
        # Clear existing views immediately for feedback (except queue)
        self.installed_package_list.clear()
        self.update_package_list.clear()
        self.category_tree.clear()
        self.browse_package_list.clear()
        self.installed_filter_input.clear() # Clear filters
        self.browse_filter_input.clear()

        # Reset data structures before refresh
        self.installed_packages = []
        self.installed_packages_map = {}
        self.available_packages_by_cat = {}
        self.update_list = []


        # Trigger all refresh actions, they will run in threads via start_worker
        self.refresh_installed_packages()
        self.refresh_updates()
        self.load_all_available_packages() # This loads categories too
        self.refresh_disk_space() # This one is usually fast, no thread needed

    # --- Data Loading Functions ---

    def load_all_available_packages(self):
        """Loads categories and all available packages using equery in a thread."""
        self.status_bar.showMessage("Loading available packages list (equery)...")
        # Don't clear tree here, clear happens in refresh_all or handler
        worker = CommandWorker(['equery', 'list', '*/*'], collect_output=True)
        worker.signals.result.connect(self._handle_available_packages_result)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err)) # Generic error handler
        worker.signals.finished.connect(self._worker_finished) # Generic finish handler
        self.start_worker(worker)

    def _handle_available_packages_result(self, output_str):
        """Parses the output of 'equery list */*' and populates the category tree."""
        try:
            local_available_packages = {} # Process locally first
            lines = output_str.strip().splitlines()
            package_pattern = re.compile(r'^\s*([\w-]+(?:/[\w-]+)*)/([\w.+-]+)-([\d].*)') # cat/subcat/pkg-ver

            for line in lines:
                if '[ Searching ... ]' in line or '[ Completed' in line: continue
                match = package_pattern.match(line.strip())
                if match:
                    category = match.group(1)
                    package_name = match.group(2)
                    full_atom = f"{category}/{package_name}" # Store cat/pkg

                    if category not in local_available_packages:
                        local_available_packages[category] = set()
                    local_available_packages[category].add(full_atom)

            # --- Update main data and Populate Tree AFTER parsing all ---
            self.available_packages_by_cat = {
                cat: sorted(list(pkgs)) for cat, pkgs in local_available_packages.items()
            } # Store sorted lists

            self.category_tree.clear()
            self.category_tree.setUpdatesEnabled(False)
            sorted_categories = sorted(self.available_packages_by_cat.keys())
            top_level_items = [QTreeWidgetItem([category]) for category in sorted_categories]
            self.category_tree.addTopLevelItems(top_level_items)
            self.category_tree.setUpdatesEnabled(True)
            # self.category_tree.sortItems(0, Qt.SortOrder.AscendingOrder) # Already sorted

            self.status_bar.showMessage("Available packages list loaded.", 5000)

        except Exception as e:
            self.show_error(f"Error parsing available packages list: {e}\n{traceback.format_exc()}")
            self.status_bar.showMessage("Error loading available packages list.", 5000)


    def category_selected(self):
        """Populates the browse list when a category selection changes."""
        selected_items = self.category_tree.selectedItems()
        self.browse_package_list.clear()
        self.browse_filter_input.clear() # Clear filter when category changes
        if not selected_items:
            return # No category selected

        category_item = selected_items[0]
        category = category_item.text(0)

        if category in self.available_packages_by_cat:
            packages = self.available_packages_by_cat[category] # Already sorted list of cat/pkg
            self.browse_package_list.addItems(packages)


    def refresh_installed_packages(self):
        """Refreshes the installed packages list using equery in a thread."""
        self.status_bar.showMessage("Loading installed packages list (equery)...")
        worker = CommandWorker(['equery', 'list', '--installed', '*/*'], collect_output=True)
        worker.signals.result.connect(self._handle_installed_packages_result)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err))
        worker.signals.finished.connect(self._worker_finished)
        self.start_worker(worker)

    def _handle_installed_packages_result(self, output_str):
        """Parses 'equery list --installed' output and updates the list widget."""
        try:
            lines = output_str.strip().splitlines()
            package_pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*)/([\w.+-]+-[\d].*)') # cat/pkg-ver
            atom_pattern = re.compile(r'^([\w-]+(?:/[\w-]+)*)/([\w.+-]+)-[\d].*') # For map: cat/pkg -> cat/pkg-ver

            local_installed_packages = []
            local_installed_map = {}

            for line in lines:
                 match = package_pattern.match(line.strip())
                 if match:
                     full_ver_pkg = match.group(0).strip() # Full line match cat/pkg-ver
                     local_installed_packages.append(full_ver_pkg)
                     atom_match = atom_pattern.match(full_ver_pkg)
                     if atom_match:
                         atom = f"{atom_match.group(1)}/{atom_match.group(2)}"
                         local_installed_map[atom] = full_ver_pkg # Map cat/pkg to cat/pkg-ver

            self.installed_packages = sorted(local_installed_packages)
            self.installed_packages_map = local_installed_map

            self.installed_package_list.clear()
            self.installed_package_list.addItems(self.installed_packages)
            self._filter_installed_list(self.installed_filter_input.text()) # Reapply filter
            self.status_bar.showMessage(f"{len(self.installed_packages)} installed packages loaded.", 5000)
        except Exception as e:
            self.show_error(f"Error parsing installed packages list: {e}\n{traceback.format_exc()}")
            self.status_bar.showMessage("Error loading installed packages list.", 5000)


    def refresh_updates(self):
        """Checks for updates using 'emerge -upvND @world' in a thread."""
        self.status_bar.showMessage("Checking for updates (emerge)...")
        command = ['emerge', '-upvND', '@world'] # pretend, verbose, update, newuse, deep
        worker = CommandWorker(command, collect_output=True) # Collect output to parse
        worker.signals.result.connect(self._handle_updates_result)
        worker.signals.error.connect(lambda cmd, err: self._command_error(cmd, err)) # Handles non-zero exit etc.
        worker.signals.finished.connect(self._worker_finished)
        self.start_worker(worker)

    def _handle_updates_result(self, output_str):
        """Parses 'emerge -upvND' output and populates the updates list."""
        try:
            local_update_list = [] # Store cat/pkg atoms
            display_items = [] # Store text for list widget + atom data

            lines = output_str.strip().splitlines()
            update_pattern = re.compile(
                 r"\[ebuild\s+(?P<type>[DUNR])(?P<block>[DS]?)\s*]\s+" # Type, Block
                 r"(?P<catpkg>[\w-]+(?:/[\w-]+)*/[\w.+-]+)-"          # Category/Package atom
                 r"(?P<oldver>[\d].*?)"                               # Old version
                 r"(?:\s+->\s*(?P<newver>[\d].*?))?"                  # Optional new version
                 # More flexible USE flag matching
                 r".*?(?:USE=\"(?P<use>.*?)\")?"
                 # Ignore repo/size for now
            )

            found_update_atoms = set() # Use set to avoid duplicates if emerge lists atom multiple times

            for line in lines:
                match = update_pattern.search(line)
                if match:
                    data = match.groupdict()
                    pkg_atom = data['catpkg'] # Actionable item is cat/pkg atom

                    if pkg_atom in found_update_atoms:
                        continue # Already processed this atom
                    found_update_atoms.add(pkg_atom)

                    local_update_list.append(pkg_atom)

                    # Build display text
                    status = data['type']
                    status_desc = {'U': 'Update', 'N': 'New', 'D': 'Downgrade', 'R': 'Rebuild'}.get(status, status)
                    display_text = f"{pkg_atom}"
                    if data['newver']:
                        display_text += f" ({data['oldver']} -> {data['newver']})"
                    else: # New or Rebuild
                        display_text += f" ({status_desc} {data['oldver']})"
                    if data['use']:
                        display_text += f" | USE: {data['use']}"

                    # Create list item and store atom
                    item = QListWidgetItem(display_text)
                    item.setData(Qt.ItemDataRole.UserRole, pkg_atom) # Store atom for later use
                    display_items.append(item)

            self.update_list = sorted(local_update_list) # Update main data

            self.update_package_list.clear()
            if not display_items:
                self.status_bar.showMessage("System is up to date.", 5000)
                no_item = QListWidgetItem("No updates available.")
                no_item.setData(Qt.ItemDataRole.UserRole, None) # No atom data
                self.update_package_list.addItem(no_item)
            else:
                self.status_bar.showMessage(f"{len(self.update_list)} updates available.", 5000)
                # Sort display items by text (which includes package name)
                display_items.sort(key=lambda x: x.text())
                for item in display_items:
                    self.update_package_list.addItem(item)

        except Exception as e:
            self.show_error(f"Error parsing update check results: {e}\n{traceback.format_exc()}")
            self.status_bar.showMessage("Error checking updates.", 5000)

    # --- Disk Space ---
    def refresh_disk_space(self):
        """Refreshes the disk space label (runs in main thread, usually fast)."""
        try:
            stats = os.statvfs('/')
            total_bytes = stats.f_blocks * stats.f_frsize
            available_bytes = stats.f_bavail * stats.f_frsize
            total_gb = total_bytes / (1024**3)
            available_gb = available_bytes / (1024**3)
            used_gb = total_gb - available_gb
            disk_info = f"Disk (/): {used_gb:.1f}/{total_gb:.1f} GB ({available_gb:.1f} GB Free)"
            self.disk_space_label.setText(disk_info)
        except Exception as e:
            self.disk_space_label.setText("Disk: Error")
            print(f"Error getting disk space: {e}") # Log error


    # --- Utility Functions ---
    def show_error(self, message):
        """Shows a critical error message box."""
        # Ensure this runs in the main thread if called from a worker (using signals is preferred)
        QMessageBox.critical(self, "Error", message)

    def closeEvent(self, event):
        """Handles the window close event, ensuring workers are stopped."""
        if self.current_action_worker: # Check if a Sync or Apply Queue is running
            reply = QMessageBox.question(self, 'Confirm Exit',
                                         "An operation (Apply Queue / Sync) is in progress. Are you sure you want to exit? The operation will be cancelled.",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)

            if reply == QMessageBox.StandardButton.Yes:
                self.status_bar.showMessage("Exiting: Cancelling running operation...")
                self.cancel_action_worker() # Attempt cancellation
                # Don't wait explicitly, just allow close
                event.accept()
            else:
                event.ignore() # Prevent closing
        elif self.active_workers > 0: # Check for non-action workers (list refreshes)
             reply = QMessageBox.question(self, 'Confirm Exit',
                                          f"{self.active_workers} background list refresh task(s) are running. Exit anyway?",
                                          QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                          QMessageBox.StandardButton.No)
             if reply == QMessageBox.StandardButton.No:
                 event.ignore()
                 return
             else:
                  print(f"Exiting with {self.active_workers} background tasks still active.")
                  # Can't easily cancel non-action workers, just exit.
                  event.accept()
        else: # No workers running
            event.accept()


# --- Main Execution ---
if __name__ == "__main__":
    if os.geteuid() == 0:
        print("\033[91mWarning:\033[0m Running this GUI directly as root is not recommended.") # Added color
        print("Please run as a regular user. Operations requiring privileges will use pkexec.")
        reply = input("Continue anyway as root? (y/N): ")
        if reply.lower() != 'y':
           sys.exit("Exiting: Please run as a non-root user.")

    if not Ansi2HTMLConverter:
        print("\n\033[93m*** WARNING: 'ansi2html' not found. Console output will not be colored. ***\033[0m\n") # Added color

    app = QApplication(sys.argv)
    main_window = GentooPackageManagerGUI()
    main_window.show()
    sys.exit(app.exec())
